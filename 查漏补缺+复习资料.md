主要复习网站：https://vue3js.cn/interview/

#### 防抖（debounce）与节流（throttle）

**防抖（debounce）**：高频事件触发时，只有最后一次触发后经过 n 毫秒才会执行回调。常用于输入框实时搜索、窗口 resize 等。

```js
function debounce(fn, delay = 300) {
  let timer = null;
  return function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

**节流（throttle）**：高频事件触发时，保证 n 毫秒内只会执行一次回调。常用于滚动、拖拽、页面 resize 等场景。

```js
function throttle(fn, delay = 300) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime > delay) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}
```

// 用法示例
window.addEventListener('scroll', throttle(() => {
console.log('滚动事件触发');
}, 500));

// 防抖和节流的区别：
// 防抖关注“最后一次”触发，节流关注“每隔一段时间”触发一次。

#### ES 模块为什么快？

Tree Shaking：由于 ESM 的 import 和 export 语句是静态声明的（即在编译时就可以确定），构建工具可以对模块依赖进行静态分析，从而识别出未使用的导出并移除它们。
它能有效减少最终打包文件的大小，进而加快加载时间。

#### new 的时候做了什么？

1. 创建一个空对象
2. 将构造函数的 this 对象绑定到新创建的空对象（具体如何绑定的呢，新对象的*proto*(原型)指向构造函数的 prototype（原型对象），这里就继承方法，再通过 call/bind/apply 改变构造函数里面的 this 指向，指向该空对象，这里继承属性）

```js
   手动实现一个 new
   function \_new(constructor, ...args) {
   // 1. 新建一个普通对象
   let obj = {};
   // 2. \_new 函数本身是可以接收参数的 但是又不知道具体会接收几个 接收什么参数 故用下面的方法
   // let [constructor, ...args] = [...arguments]; // 解构赋值 constructor 是 构造函数哈哈哈
   // 3. 建立联系 生成的这个对象是 constructor 的实例 需要使用**proto** 和 构造函数的 prototype 建立联系
   obj.**proto** = constructor.prototype;
   // 4. 执行 constructor 构造函数 并且 this 指向 自己新建的对象
   let result = constructor.apply(obj, args);
   // 5. 判断构造函数是否返回的是 对象或者 函数 是的话直接返回这个结果 如果不是 那么返回 自己创建的 obj 对象
   if (result && (typeof (result) == "object" || typeof (result) == "function")) {
   return result;
   }
   return obj;
   }
```

3. 执行构造函数中的代码·
4. 默认情况下，构造函数没有显式的 return 语句，这时 new 表达式会自动返回这个新创建的对象（即 this）。然而，如果构造函数中有显式的 return 语句，并且返回的是一个对象，则返回的将是这个对象而不是新创建的实例。如果返回的是一个原始类型（如数字、字符串等），则忽略该返回值，仍然返回新创建的实例。

#### 原型链的理解

prototype 是原型对象 每个对象下面都有*proto*原型，*proto*原型再指向内置对象 Object，Object 也有*proto*原型，但是是 null

原型链继承，就是构造函数的原型对象指向新的构造函数再 new 一下，缺点：当子级实例化多个对象后，在父级的数据是同一内存空间，会互相影响

试图修改 this 的值是不允许的。this 的值取决于函数的调用方式，而不是可以在函数体内随意改变的变量。

**执行上下文**是一个动态的概念，描述了代码执行的具体环境，包括变量对象、作用域链和 this 绑定等信息。每次函数调用都会创建一个新的执行上下文。
**作用域**是一个静态的概念，描述了变量的可访问性规则。它是根据代码的书写位置来决定的，不会随执行上下文的变化而变化。也就是说，变量的作用域是在编写代码时就确定了的。

#### 动态的柯里化：

```js
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      // 如果收集到的参数数量达到了原函数需要的数量，则直接调用原函数
      return fn.apply(this, args);
    } else {
      // 否则返回一个新的函数，继续收集参数
      return function (...args2) {
        // 将新旧参数合并后递归调用 curried
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

// 使用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 输出: 6
console.log(curriedAdd(1, 2)(3)); // 输出: 6
console.log(curriedAdd(1)(2, 3)); // 输出: 6
console.log(curriedAdd(1, 2, 3)); // 输出: 6
```

#### 事件循环机制

JavaScript 是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环
同步任务在执行栈中立即执行，异步任务在事件队列中，异步任务分为微任务与宏任务
async/await 会阻塞代码运行，等待 await 后面的代码完毕后，下面的代码，会被视作微任务，加入任务队列（事件队列），按顺序执行

```js
async function test() {
  await console.log(1);
}
test();
console.log(2);
// 打印 1 2

async function test() {
  await Promise.resolve().then(() => {
    console.log(1);
  });
}
test();
console.log(2);
// 打印 2 1

async function aa() {
  await Promise.resolve().then(() => {
    console.log(1);
  });
  Promise.resolve().then(() => {
    console.log(4);
  });
}
function bb() {
  Promise.resolve().then(() => {
    console.log(5);
  });
}
aa();
console.log(2);
bb();
// 打印 2 1 5 4
```

跑到 await 时，await 同行的代码是同步代码的，则先执行，假如是异步代码，则根据宏任务微任务，按顺序执行，await 下一行的代码往下都是微任务，如果下一行没代码，则把**函数运行的完成**推到微队列（这个概念很重要）
凡是标记了 async 的函数，返回的都是一个 Promise，凡是看到 await，一定会等待后面的 Promise 完成，如果不是 Promise，则会把数字、对象等按照这种形式返回，Promise.resolve(123)

事件队列（异步任务待的地方）和执行栈（同步任务待的地方）其实是一个“先进先出”的数据结构
执行栈符合先进后出（LIFO）

##### 常见的宏任务：

主代码块
setTimeout 理解：多少秒之后，把一个函数推到宏队列，这就是计时器的作用
setInterval
setImmediate ()-Node
requestAnimationFrame ()-浏览器
DOM 事件回调（如 click、mousemove、mouseenter、mouseleave 等）

##### 常见的微任务：

Promise.then()
catch
finally
Object.observe
MutationObserver

```js
console.log("Script start");

// 宏任务之前的微任务
Promise.resolve().then(() => {
  console.log("Microtask 1");
});

// 宏任务
setTimeout(() => {
  console.log("Macrotask");

  // 宏任务内的微任务
  Promise.resolve().then(() => {
    console.log("Microtask inside Macrotask");
  });
}, 0);

// 宏任务之后的微任务
Promise.resolve().then(() => {
  console.log("Microtask 2");
});

console.log("Script end");
// 结果
// Script start
// Script end
// Microtask 1
// Microtask 2
// Macrotask
// Microtask inside Macrotask
```

很明显，async/await 在的那一行代码，阻塞并立即运行，并且下面的代码都是微任务，放入任务队列（事件队列）按顺序执行

以下是一个简单的例子：

```js
new Promise((resolve, reject) => {
  resolve();
}).then(() => {
  console.log("then1");
});
async function fn1() {
  console.log(1);
  await fn2();
  console.log(2); // 阻塞
}

async function fn2() {
  console.log("fn2");
}

fn1();
console.log(3);
new Promise((resolve, reject) => {
  resolve();
}).then(() => {
  console.log("then2");
});
//1 fn2 3 then1 2 then2
```

以下是一个困难的例子：

```js
async function asy1() {
  console.log(1);
  await asy2();
  console.log(2);
}
const asy2 = async () => {
  await setTimeout(() => {
    Promise.resolve().then(() => {
      console.log(3);
    });
    console.log(4);
  }, 0);
};
const asy3 = async () => {
  Promise.resolve().then(() => {
    console.log(6);
  });
};
asy1();
console.log(7);
asy3();
// 打印 1 7 6 2 4 3

async function asy1() {
  console.log(1);
  await asy2();
  console.log(2);
}
const asy2 = async () => {
  await (async () => {
    await (() => {
      console.log(3);
    })();
    console.log(4); // 关键在于 await 后面的同步代码是立即执行的，只有异步代码才会进任务队列（宏任务、微任务），并且执行完后会将下面的代码，会以微任务的形式进微任务队列 哪怕没有这一行，输出是 // 1 3 7 6 2，执行完 console.log(3)后 将整个函数完成推到微任务，等待确认完成 才会将 上面的 console.log(2);推到微任务
  })();
};
const asy3 = async () => {
  Promise.resolve().then(() => {
    console.log(6);
  });
};
asy1();
console.log(7);
asy3();
// 1 3 7 4 6 2
```

#### 内存泄漏的情况

1. 闭包
2. 全局变量
3. 组合函数（最里层的函数的返回结果作为外面一层的参数，从右到左执行）：通常指的是从右到左的应用函数顺序（尽管有些库可能提供不同的方向）。它适合于当你有一个明确的函数序列需要按特定顺序执行时。
4. 管道函数（从左往右执行）：更多地强调数据流的方向，通常是直观的从左到右。这种方式对于构建可读性强、易于理解的数据处理流水线特别有用。

#### 闭包的理解：

```js
function a(x) {
  function b() {
    console.log(x++);
  }
  return b;
}
a(1)();
a(1)();
a(1)();
a(1); // 形成了多个闭包的缓存空间，只是看不出来 因为没累加

let c = a(1); // 形成了闭包空间，x变量已经缓存起来了，等待后续的调用实现累加
c();
c();
c();
```

闭包是在 a 函数执行的时候才形成的，函数分为三个阶段，声明（即变量提升）定义（即具体的函数体）调用（即开始运行函数体里面的代码）
c();

#### 闭包为何会形成

闭包产生的根源是词法作用域链的持久化：函数在定义时会捕获外层环境的引用，而不是调用点。当内部函数被返回或在外部调用时，该作用域链仍需可用。

- **AO（Activation Object）活动对象**：函数每次执行都会创建活动对象，存放形参、局部变量、内部函数声明等。AO 属于当前执行上下文。
- **VO（Variable Object）变量对象**：规范上 VO 是抽象概念，在函数执行时由 AO 具体化；对于全局上下文则由 GO（Global Object）充当。
- **作用域链（Scope Chain）**：当前执行上下文的 AO 放在链表头部，后续指向外层上下文的 AO/VO，最终到达 GO。编译阶段就确定链路次序。
- 当内部函数被返回时，它的 [[Environment]] 指针仍指向创建时的外层 AO/VO，使得这些活动对象不会被垃圾回收，从而形成闭包。
- 因此闭包的本质是：函数携带着其创建时的词法环境（AO/VO 组成的作用域链），在后续执行中继续访问这些被“记住”的变量。

#### Environment 是什么

- 每个执行上下文都包含两个与作用域相关的内部组件：**LexicalEnvironment** 与 **VariableEnvironment**，早期常笼统地称作 Environment。
- LexicalEnvironment 由环境记录器（Environment Record）和外部引用（outer）构成，记录器保存当前上下文中的绑定（let/const、函数声明等），outer 指向外层环境并串联成作用域链。
- VariableEnvironment 在函数上下文中用于存放 var 声明与函数声明，实际实现通常映射到 AO/VO；在现代引擎里它往往与 LexicalEnvironment 共用同一结构，但语义上仍区分 var 与 let/const 的绑定位置。
- 闭包里的 [[Environment]] 指针就是指向创建时的 LexicalEnvironment/VariableEnvironment，因此外层变量在函数返回后仍被保留，可供后续调用访问。

#### 设备像素比（DPR）

DPR = 1：每个 CSS 像素对应一个物理像素（也叫设备像素）。
DPR = 2：每个 CSS 像素对应四个物理像素（也叫设备像素）（2x2 网格）。
DPR = 3：每个 CSS 像素对应九个物理像素（也叫设备像素）（3x3 网格）。
实际分辨率（也叫设备像素）：指的是屏幕上的总物理像素数。例如，一部 iPhone 12 的分辨率为 1170px x 2532px。
一个 px 就是每个 CSS 像素（也叫设备独立像素）
ppi （pixel per inch），每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像
设备像素比（dpr） = 设备像素 / 设备独立像素
每英寸物理像素密度（ppi），值越大，图像越清晰

#### bfc 可以清除浮动、防止 margin 塌陷、更好的控制布局

注意：浮动只脱离了文档流，没有脱离文本流，文本还是会给浮动元素腾位置的

#### flex 的三个参数

1. flex-grow：等分剩余空间的比例，平时用的 flex:1
2. flex-shrink：弹性盒子在空间不足时的收缩比例。

- 作用：当父容器空间不足时，子项会按照 flex-shrink 的比例进行缩小。
- 默认值：1（允许收缩）
- 设为 0：不收缩，无论空间多小都保持原始宽度。
- 设为 n：收缩速度是设为 1 的 n 倍。

举例：
假设有两个子项，A 的 flex-shrink: 1，B 的 flex-shrink: 2。
当父容器空间不足时，B 收缩的宽度是 A 的 2 倍。

3. flex-basis：定义了在分配剩余空间之前，弹性项目的基础大小。它可以设置为具体的长度值（如 px, em 等），也可以是百分比或者关键字 auto。auto 表示使用元素的默认尺寸或由内容决定的尺寸。

#### 内容变化也会触发重排

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列
当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 offsetTop 等方法都会返回最新的数据
因此浏览器不得不清空队列，触发回流重绘来返回正确的值

##### 减少重绘重排的方法：

1. 批量修改样式
2. 最小化布局的读写操作，因为每次获取 offsetTop 等方法，都会强制队列重排重绘，所以尽可能地一次性获取全部的，存起来
3. 使用 transform 和 opacity 进行动画，GPU 加速，避免重排/重绘因为他们不会影响元素的位置，不会发生重排，只会发生重绘，
   不能被 GPU 加速的属性（例如 width, height, top, left, margin 等），则可能会导致频繁的重排和重绘，降低动画的流畅度。
4. 避免不必要的复杂选择器，因为层级过深，计算成本高，会造成性能问题，可维护性也差，层级过深，想要覆盖之前的样式，又得写一堆
5. 减少真实 DOM 的操作

强制使用 GPU 加速： transform: translateZ(0); /_ 强制 GPU 加速 _/
即使只是二维变换，也可以通过添加一个 3D 变换属性来提示浏览器使用 GPU 加速。

**跨域**: 协议、域名、端口三者有一者不一样 都算
**web 服务器**：Apache，有很多处理引擎，例如：针对 php 的 html 的处理引擎

#### 进程 线程

- 进程是操作系统对正在运行中的程序进行资源分配和调度的基本单位，一般由程序、数据集合和进程控制块三部分组成：
  程序用于描述进程要完成的功能，是控制进程执行的指令集
  数据集合是程序在执行时所需要的数据和工作区
  程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志

- 线程是进程内的一个执行单元，也是进程内的实际运作单位，负责当前进程中程序的执行，操作系统能够进行运算调度的最小单位
  一个线程在同一进程中可以有多个兄弟线程，它们共享进程的资源，同进程的线程资源共享，不同的就无法共享了

#### iframe 会引发性能问题：

1. 额外的 HTTP 请求：每个 <iframe> 都会发起一个独立的 HTTP(S)请求来获取其内容。这意味着如果页面中有多个 <iframe>，浏览器需要同时处理更多的网络请求，这可能会显著增加总的加载时间。
2. 资源竞争：当页面包含 <iframe> 时，浏览器需要为该 <iframe> 分配资源（如内存、CPU 等），这可能会减少可用于主页面加载和渲染的资源量，尤其是在资源有限的情况
3. 阻塞行为：默认情况下，<iframe> 的加载是同步的，即浏览器会等待 <iframe> 内容完全加载后才会继续执行后续操作，如果 <iframe>含有或依赖于 JavaScript 文件，而这些 js 文件正好阻塞了代码（即有个请求时间很长的请求），就会影响页面其他部分的加载
4. 重排和重绘：<iframe> 不指定大小，会触发额外的重排和重绘

##### 如何减轻 <iframe> 对页面加载的影响：

1. 懒加载：使用 loading="lazy" 属性
   <img src="example.jpg" loading="lazy" alt="示例图片">
2. 明确尺寸
3. 异步加载 <iframe> 标签引用页面的 js 脚本，async 和 defer 属性用于 <script> 标签上，它们的目的恰恰是为了避免阻塞页面的解析。（<script src="example.js" async></script> <script src="example.js" defer></script>）

async 属性：一旦脚本下载完成，浏览器将**立即中断 HTML（DOM 渲染） 解析，不会中断 css 渲染**来执行这个脚本。
defer 属性：会在整个 HTML 文档完全解析完成后（**DOM 渲染完成后，并不关注 css 渲染是否完成**） 但在 DOMContentLoaded 事件触发之前执行，操作 dom 的脚本适合用这个。

#### 正向代理（Forward Proxy）

正向代理通常用于保护客户端隐私或突破网络限制。它位于客户端和目标服务器之间，代表客户端发起对外部资源的请求。这种情况下，**服务器不知道访问者是谁！！！**
例子：假设你在中国，想要访问被封锁的 Facebook 网站。你可以配置你的浏览器使用一个位于美国的正向代理服务器。当你尝试访问 Facebook 时，实际上是你的请求先发送到这个美国的代理服务器，然后由该代理服务器转发请求并接收响应，再将结果返回给你。

#### 反向代理（Reverse Proxy）

反向代理则主要用于保护内部网络的安全性、负载均衡等目的。它位于客户端和一组内部服务器之间，代表内部服务器处理来自外部客户端的请求。这种情况下，**客户端不知道自己访问的真正地址！！！**
例子：考虑一个大型网站如淘宝，它可能有成百上千台服务器来处理用户的请求。但是，用户并不直接访问这些服务器中的某一台，而是通过一个反向代理服务器来分发请求。这个反向代理根据一定的策略（比如负载均衡算法）选择合适的后台服务器来处理每个请求，并将结果返回给用户。这样做的好处包括提高安全性、隐藏实际服务端架构以及优化资源利用等。

#### 反向代理可能遇到的问题：

1. WebSocket 支持：默认情况下，Nginx 对 WebSocket 的支持需要额外配置。
2. 性能问题：如果后端服务器响应缓慢，可能会导致客户端等待时间增加。
3. 安全问题：不当的配置可能导致内部网络暴露给外部攻击者，因此必须仔细配置访问控制和验证机制。
4. 缓存问题：如果后端内容频繁变化但 Nginx 缓存策略设置不合理，可能会导致用户看到过期数据。
5. 错误处理：需要妥善处理后端服务器返回的各种错误状态码，并正确地将它们传递给客户端。还有路由问题，都不在 nginx 里面处理，都交给前端的路由。
   root /data/dist;
   index index.html;

   location / {
   try_files $uri $uri/ /index.html;
   }

先配置一个 index 的路径，在配置不管什么 url，都重定向到 index 下面去

##### 服务端渲染：

一般只有首页需要 ssr，那么首页的路由配置那里就不再是
{
path:'/',
name: 'index',
component: () => import('@/page/home/Home.vue'),
}
而是：
import App from './App.vue';
{
path: '/',
component: App
},
首页的组件不再是一个组件继续依靠路由规则放在 index.html 的 <main id="app"></main>，而是去请求 App.vue，从而触发服务端渲染
当访问首页 / 的时候，server.ts 所监听的 app.get("/")便会触发

```js
// server.ts
import express from "express";
import { createSSRApp } from "vue";
import { renderToString } from "@vue/server-renderer";
import App from "../client/App.vue";
import fs from "fs";
import path from "path";

const app = express();
const PORT = process.env.PORT || 3000;

// 处理根路径请求，进行 SSR
app.get("/", async (req, res) => {
  const vueApp = createSSRApp(App);
  const appHtml = await renderToString(vueApp);
  const indexHtml = fs.readFileSync(
    path.resolve(__dirname, "../index.html"),
    "utf-8"
  );
  const html = indexHtml.replace(
    '<div id="app"></div>',
    `<div id="app">${appHtml}</div>`
  );
  res.send(html);
});

// 处理其他路径请求，返回静态 HTML
app.get("*", (req, res) => {
  const indexHtml = fs.readFileSync(
    path.resolve(__dirname, "../index.html"),
    "utf-8"
  );
  res.send(indexHtml);
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

#### 抓包

Wireshark，可以通过 ip.src 输入 ip，过滤指定的 http 数据包

#### 纯函数

优点：

1. 可预测性：同样的输入，给出的都是同样的输出
2. 易于调试：不依赖外部环境或变量
3. 并行 / 并发安全：不依赖共享状态，无需锁机制，可在多线程 / Worker 中安全并行执行
4. 可维护性：依赖关系完全通过参数显式表达，避免了对全局状态的隐式依赖，使代码更易于理解和重构

缺点：

1. 重复计算：对于相同的输入，它会始终返回相同的结果。这可能导致在某些情况下出现重复计算，浪费计算资源和时间
2. 难以优化：一些在有副作用的函数中容易实现的优化，在纯函数中可能会变得困难。因为纯函数的不可变性和独立性，使得编译器或解释器难以进行某些全局优化，例如，无法通过修改共享状态来避免不必要的计算
3. 难以处理复杂业务逻辑：修改外部状态或依赖于外部环境，使用纯函数来实现可能会非常复杂，甚至难以实现
4. 状态管理复杂：由于纯函数本身不能直接修改外部状态，因此需要通过传递状态对象或使用其他方式来模拟状态变化，这可能会增加代码的复杂性和维护成本

#### 如何防止尾递归 内存溢出

1. 转为迭代的方式，就是将递归逻辑改写为循环结构（for (let i = 2; i <= n; i++)）
2. 手动实现尾递归优化（Trampoline 模式）
   通过 ** 蹦床函数（Trampoline）** 将递归转换为循环执行，每次递归调用返回一个函数而非直接执行

```js
// 原始尾递归函数（未优化）
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  return sum(n - 1, acc + n); // 普通递归调用
}

// 优化：返回待执行的函数而非直接递归
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  return () => sum(n - 1, acc + n); // 返回函数
}

// 蹦床函数：循环执行返回的函数直到得到结果
// 蹦床函数（trampoline）可以优化递归、避免栈溢出，是因为它把递归调用“变成了循环”
function trampoline(fn) {
  return function (...args) {
    let result = fn(...args);
    while (typeof result === "function") {
      result = result();
    }
    return result;
  };
}

// 使用蹦床函数包装原始函数
const safeSum = trampoline(sum);
console.log(safeSum(100000)); // 不会栈溢出
```

3. 使用生成器,每次都得 next 一下，避免一次调用很多次

#### lighthouse 衡量网站性能指标是什么

1. 加载性能指标
   FCP (First Contentful Paint)
   定义：首次有内容（文本、图片、SVG 等）渲染到屏幕的时间。
   意义：衡量页面的初始加载速度，反映用户感知到的 “页面开始加载” 时间。
   目标：在 1.8 秒 内完成（移动端）。
   LCP (Largest Contentful Paint)
   定义：视口中最大可见元素（如图片、视频或文本块）完成渲染的时间。
   意义：衡量主要内容的加载速度，是用户感知页面 “可用” 的关键指标。
   目标：在 2.5 秒 内完成（移动端）。
2. 交互性指标
   FID (First Input Delay)
   定义：用户首次与页面交互（如点击按钮）到浏览器实际响应的时间延迟。
   意义：衡量页面的响应能力，延迟过长会让用户感到卡顿。
   目标：小于 100 毫秒（移动端）。
   TTI (Time to Interactive)
   定义：页面完全可交互的时间点（所有资源加载完成，能够快速响应操作）。
   意义：衡量页面从 “加载中” 到 “可使用” 的转变速度。
   目标：在 3.8 秒 内完成（移动端）。
3. 视觉稳定性指标
   CLS (Cumulative Layout Shift)
   定义：页面加载过程中，元素位置突然变化的累积度量（布局偏移分数）。
   意义：衡量页面内容的视觉稳定性，避免意外的布局变动干扰用户操作。
   目标：小于 0.1（分数越低越好）。
4. 其他 Lighthouse 指标
   SI (Speed Index)
   定义：页面内容逐步渲染的速度，通过计算可见区域填充的平均时间得出。
   意义：评估整体加载体验的流畅度。
   目标：在 4.0 秒 内完成（移动端）。
   TBT (Total Blocking Time)
   定义：FCP 到 TTI 之间，主线程被阻塞无法响应用户输入的总时间。
   意义：衡量页面在加载过程中的无响应程度。
   目标：小于 300 毫秒（移动端）。

报告解读示例
Lighthouse 会为每个指标给出 0-100 的分数：

绿色（90-100）：良好
黄色（50-89）：需要改进
红色（0-49）：性能较差

#### 把一个一维数组 list 变成树状结构

```js
// 假设 list 是 [{id: 1, parentId: null}, {id: 2, parentId: 1}, ...]
const idMap = new Map();
const result = [];

list.forEach((item) => {
  idMap.set(item.id, { ...item, children: [] });
});

list.forEach((item) => {
  const node = idMap.get(item.id);
  if (!item.parentId) {
    result.push(node);
  } else {
    const parent = idMap.get(item.parentId);
    if (parent) {
      parent.children.push(node);
    }
  }
});
```

#### 属性访问器

1. 对象写法：

```js
let obj = {
  _val: 0,
  get val() {
    return this._val;
  },
  set val(v) {
    this._val = v;
  },
};
obj.val = 100; // 触发 set
console.log(obj.val); // 100
```

2. 全局写法（不推荐，语法支持）：

```js
let _x = 0;
function get x() { return _x; }
function set x(v) { _x = v; }
x = 123; // 触发 set
console.log(x); // 123
```

3. class 写法（推荐）：

```js
class Demo {
  get y() {
    return this._y;
  }
  set y(v) {
    this._y = v;
  }
}
const d = new Demo();
d.y = 5; // 触发 set
console.log(d.y); // 5
```

**属性类型与描述符**：

JavaScript 对象属性分为两种类型，每种都有对应的描述符（descriptor）：

| 描述符         | 数据属性 | 访问器属性 | 字面量默认  | defineProperty 默认 | 说明            |
| -------------- | -------- | ---------- | ----------- | ------------------- | --------------- |
| `value`        | ✅       | ❌         | 属性值      | `undefined`         | 存储属性值      |
| `writable`     | ✅       | ❌         | `true`      | `false`             | 值是否可修改    |
| `get`          | ❌       | ✅         | `undefined` | `undefined`         | 读取时调用      |
| `set`          | ❌       | ✅         | `undefined` | `undefined`         | 设置时调用      |
| `enumerable`   | ✅       | ✅         | `true`      | `false`             | 是否可枚举      |
| `configurable` | ✅       | ✅         | `true`      | `false`             | 是否可配置/删除 |

**核心描述符说明**：

**1. enumerable（可枚举性）**：控制属性是否出现在 `for...in`、`Object.keys()`、`JSON.stringify()` 中

```js
let obj = { name: "John", age: 30 };
Object.defineProperty(obj, "password", {
  value: "123456",
  enumerable: false, // 不可枚举
});

console.log(Object.keys(obj)); // ['name', 'age']
console.log(obj.password); // '123456'（仍可直接访问）
console.log(JSON.stringify(obj)); // {"name":"John","age":30}
```

**2. configurable（可配置性）**：控制属性是否可删除、是否可修改描述符（不可逆操作）

```js
Object.defineProperty(obj, "id", {
  value: 123,
  configurable: false, // 不可配置
});

delete obj.id; // 删除失败（严格模式报错）
obj.id = 456; // 可修改值（如果 writable: true）
```

**3. writable（可写性）**：控制数据属性的值是否可修改

```js
Object.defineProperty(obj, "PI", {
  value: 3.14159,
  writable: false, // 不可写
});

obj.PI = 3.14; // 赋值失败（严格模式报错）
console.log(obj.PI); // 3.14159
```

**实用示例**：

```js
let obj = {};

// 定义常量（不可修改、不可删除）
Object.defineProperty(obj, "MAX_SIZE", {
  value: 100,
  writable: false,
  configurable: false,
  enumerable: true,
});

// 定义私有属性（不可枚举、可删除）
Object.defineProperty(obj, "_token", {
  value: "secret",
  enumerable: false,
  configurable: true,
});

// 定义访问器属性
Object.defineProperty(obj, "fullName", {
  get() {
    return `${this.first} ${this.last}`;
  },
  set(val) {
    [this.first, this.last] = val.split(" ");
  },
  enumerable: true,
  configurable: true,
});

console.log(Object.keys(obj)); // ['MAX_SIZE']
```

**注意事项**：

- 数据属性不能同时有 `value`/`writable` 和 `get`/`set`

```js
// _value 是数据属性，value 是访问器属性
// 也就是说下面是可以的
let obj = {
  _value: 0,
  get value() {
    return this._val;
  },
  set value(v) {
    this._val = v;
  },
};
// 但是 下面 不可以
let obj = {
  value: 0,
  get value() {
    return this._val;
  },
  set value(v) {
    this._val = v;
  },
};
```

- `configurable: false` 后几乎无法再修改（不可逆）
- `writable: false` + `configurable: true` 时可通过重定义描述符改变值

<!-- 例题： a  b=a+1 c=b+1 d=a+b -->

```js
let \_a = 0;
let \_b, \_c, \_d;
let dirty = { b: true, c: true, d: true };

function setA(val) {
\_a = val;
dirty.b = dirty.c = dirty.d = true;
}
function get b() {
if (dirty.b) { \_b = \_a + 1; dirty.b = false; dirty.c = true; dirty.d = true; }
return \_b;
}
function get c() {
if (dirty.c) { \_c = b + 1; dirty.c = false; }
return \_c;
}
function get d() {
if (dirty.d) { \_d = \_a + b; dirty.d = false; }
return \_d;
}

// 用法
setA(5);
console.log(b, c, d); // 6, 7, 11
```

### for...of 和 for...in 的用法与区别

#### 1. for...in

- 用于遍历对象的可枚举属性（包括自有属性和继承属性，顺序不保证）。
- 也可用于遍历数组的索引（下标），但不推荐。
- 语法：
  ```js
  for (let key in obj) {
    // key 是属性名（字符串）
    console.log(key, obj[key]);
  }
  ```
- 适合遍历对象属性，不适合遍历数组元素。

#### 2. for...of

- 用于遍历可迭代对象（如数组、字符串、Set、Map、arguments、DOM 集合等）。
- 不能直接遍历普通对象（除非实现了 Symbol.iterator）。
- 语法：
  ```js
  for (let value of arr) {
    // value 是每一项的值
    console.log(value);
  }
  ```
- 适合遍历数组、类数组、字符串、Set、Map 等。

#### 3. 主要区别

| 对比点   | for...in                 | for...of                       |
| -------- | ------------------------ | ------------------------------ |
| 遍历对象 | ✅（属性名）             | ❌（除非实现 Symbol.iterator） |
| 遍历数组 | ✅（索引，类型为字符串） | ✅（值，类型为元素本身）       |
| 遍历顺序 | 不保证顺序               | 保证顺序（按迭代器顺序）       |
| 继承属性 | 会遍历                   | 不会遍历                       |
| 推荐场景 | 对象属性遍历             | 数组、类数组、可迭代对象遍历   |

#### 4. 示例

```js
const arr = ["a", "b", "c"];
arr.foo = "bar";

for (let i in arr) {
  console.log(i); // 0, 1, 2, foo
}
for (let v of arr) {
  console.log(v); // 'a', 'b', 'c'
}

const obj = { x: 1, y: 2 };
for (let k in obj) {
  console.log(k); // x, y
}
// for...of(obj) 会报错 unless obj[Symbol.iterator]
```

#### 5. 总结

- for...in 用于遍历对象属性（包括数组索引），遍历的是“键/属性名”。
- for...of 用于遍历可迭代对象，遍历的是“值”。
- 遍历数组推荐用 for...of，遍历对象推荐用 for...in。

#### Symbol.iterator 介绍

Symbol.iterator 是 ES6 引入的一个内置 Symbol，用于定义对象的默认迭代器方法。只要对象实现了 Symbol.iterator 方法，就可以被 for...of、扩展运算符、Array.from 等迭代。
**for...of 迭代器协议要求 [Symbol.iterator] 返回一个有 next 方法的对象**

- 常见可迭代对象：Array、String、Set、Map、arguments、TypedArray 等都内置了 Symbol.iterator。
- 普通对象（Object）默认没有迭代器，不能直接 for...of。

**用法示例：**

```js
const arr = [1, 2, 3];
const iter = arr[Symbol.iterator]();
console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: undefined, done: true }
```

**自定义可迭代对象：**

```js
const obj = {
  data: [10, 20, 30],
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => ({
        value: this.data[i++],
        done: i > this.data.length,
      }),
    };
  },
};

for (const v of obj) {
  console.log(v); // 10, 20, 30
}
```

**应用场景：**

- for...of 遍历
- 扩展运算符 ...
- Array.from、Set、Map 等
- 生成器函数默认实现 Symbol.iterator

**总结：**
Symbol.iterator 是实现对象可迭代协议的关键，只要实现了这个方法，就能让对象像数组一样被 for...of、... 等语法遍历。

#### 什么是可序列化的数据

- 可序列化的数据，指的是能够被 JSON.stringify 正确转换为 JSON 字符串，并且能用 JSON.parse 还原的数据类型。常见的可序列化数据包括：

基本类型：number、string、boolean、null
普通对象（Object）、数组（Array）
嵌套的对象和数组

- 不可序列化的数据包括：

函数、Symbol、undefined
特殊对象类型（如 Date、RegExp、Map、Set、Error、BigInt、NaN、Infinity、DOM 节点等）
循环引用的对象

#### bind、apply、call 的用法和区别

**共同点：**
三者都是用来改变函数内部 this 指向的方法。

**区别与用法：**

1. **call**

   - 语法：`fn.call(thisArg, arg1, arg2, ...)`
   - 作用：立即调用函数，this 指向 thisArg，后续参数为函数参数列表。
   - 示例：
     ```js
     function show(a, b) {
       console.log(this.x, a, b);
     }
     show.call({ x: 1 }, 2, 3); // 输出 1 2 3
     ```

2. **apply**

   - 语法：`fn.apply(thisArg, [argsArray])`
   - 作用：立即调用函数，this 指向 thisArg，第二个参数是参数数组。
   - 示例：
     ```js
     function show(a, b) {
       console.log(this.x, a, b);
     }
     show.apply({ x: 1 }, [2, 3]); // 输出 1 2 3
     ```

3. **bind**
   - 语法：`fn.bind(thisArg, arg1, arg2, ...)`
   - 作用：返回一个新的函数，this 永久绑定为 thisArg，参数可预先传递一部分（柯里化），不会立即执行，需要手动调用。
   - 示例：
     ```js
     function show(a, b) {
       console.log(this.x, a, b);
     }
     const bound = show.bind({ x: 1 }, 2);
     bound(3); // 输出 1 2 3
     ```
4. **手动实现**

   ```js
   Function.prototype.myCall = function (context, ...args) {
     // 如果 context 为 null 或 undefined，则默认指向全局对象
     // 在浏览器环境下，globalThis 指向 window。在 Node.js 环境下，globalThis 指向 global。在 Web Worker 等其他环境下，也能正确指向对应的全局对象。

     context = context || globalThis;
     // 用 Symbol 作为临时属性名，避免覆盖原有属性
     const fnSymbol = Symbol();
     context[fnSymbol] = this; // 这里的 this 是要调用的原函数（如 show）
     const result = context[fnSymbol](...args);
     delete context[fnSymbol];
     return result;
   };

   // 示例
   function show(a, b) {
     console.log(this.x, a, b);
   }
   show.myCall({ x: 1 }, 2, 3); // 输出 1 2 3
   ```

   **为什么不能直接 `this(...args)`？**

   - 如果直接 `this(...args)`，函数内部的 this 指向不会改变，仍然是原来的上下文（window 或其他）。
   - 通过 `context[fnSymbol] = this` 把函数挂载到 context 对象上，再用 `context[fnSymbol](...args)` 调用，利用"谁调用函数，this 就指向谁"的规则，此时函数内的 this 就指向了 context。
   - 这就是 call 的核心实现原理：通过对象方法调用的方式改变 this 指向。

   **执行流程示例：**

   ```js
   // 调用 show.myCall({ x: 1 }, 2, 3) 时：
   // 1. myCall 中的 this 是 show 函数
   // 2. context 是 { x: 1 }
   // 3. context[fnSymbol] = show（把 show 挂到 { x: 1 } 上）
   // 4. context[fnSymbol](2, 3)（相当于 { x: 1 }.show(2, 3)）
   // 5. show 函数内的 this 就指向了 { x: 1 }
   ```

**总结对比：**

| 方法  | 是否立即执行 | 参数传递方式       | 返回值       |
| ----- | ------------ | ------------------ | ------------ |
| call  | 是           | 依次传递           | 函数执行结果 |
| apply | 是           | 数组传递           | 函数执行结果 |
| bind  | 否           | 依次传递（可预设） | 新函数       |

**补充说明：**

- bind 返回的新函数可多次调用，且 this 永远绑定。
- call/apply 主要用于函数借用、继承、伪数组转数组等场景。
- bind 常用于事件回调、定时器、柯里化等。

#### JavaScript 判断类型的几种方式

1. **typeof**

   - 用法：`typeof 变量`
   - 结果：返回字符串，常见有 'number'、'string'、'boolean'、'undefined'、'object'、'function'、'symbol'、'bigint'。
   - 特点：
     - 能区分基本类型（除了 null，typeof null === 'object' 是历史遗留问题）。
     - 不能区分数组、对象、null。
   - 示例：
     ```js
     typeof 123; // 'number'
     typeof "abc"; // 'string'
     typeof null; // 'object'
     typeof []; // 'object'
     typeof {}; // 'object'
     typeof (() => {}); // 'function'
     ```

2. **instanceof**

   - 用法：`变量 instanceof 构造函数`
   - 结果：返回布尔值。
   - 特点：
     - 用于判断引用类型（对象、数组、函数等）是否为某构造函数的实例。
     - 不能判断基本类型。
     - 受原型链影响。
   - 示例：
     ```js
     [] instanceof Array; // true
     {} instanceof Object; // true
     (() => {}) instanceof Function; // true
     123 instanceof Number; // false
     new Number(123) instanceof Number; // true
     ```

3. **Object.prototype.toString.call**

   - 用法：`Object.prototype.toString.call(变量)`
   - 结果：返回如 '[object Type]' 的字符串。
   - 特点：
     - 能精确区分所有内置类型（包括 null、undefined、Array、Date、RegExp、Function、Arguments、Map、Set 等）。
     - 推荐用于复杂类型判断。
   - 示例：
     ```js
     Object.prototype.toString.call([]); // '[object Array]'
     Object.prototype.toString.call(null); // '[object Null]'
     Object.prototype.toString.call(undefined); // '[object Undefined]'
     Object.prototype.toString.call(123); // '[object Number]'
     Object.prototype.toString.call({}); // '[object Object]'
     ```

4. **constructor 属性**

   - 用法：`变量.constructor === 构造函数`
   - 特点：
     - 可判断大部分对象类型。
     - null 和 undefined 没有 constructor 属性，使用时需注意。
     - constructor 可被重写，不绝对安全。
   - 示例：
     ```js
     (123).constructor === Number; // true
     [].constructor === Array; // true
     ({}).constructor === Object; // true
     ```

5. **Array.isArray**
   - 用法：`Array.isArray(变量)`
   - 特点：
     - 专门判断是否为数组。
     - 推荐判断数组类型。
   - 示例：
     ```js
     Array.isArray([]); // true
     Array.isArray({}); // false
     ```

**常用类型判断对比总结：**

| 方法                      | 能判断基本类型 | 能判断对象类型 | 能判断数组 | 能判断 null/undefined | 备注                 |
| ------------------------- | :------------: | :------------: | :--------: | :-------------------: | -------------------- |
| typeof                    |       ✅       |       ❌       |     ❌     |  null 错误为 object   | 基本类型首选         |
| instanceof                |       ❌       |       ✅       |     ✅     |          ❌           | 受原型链影响         |
| Object.prototype.toString |       ✅       |       ✅       |     ✅     |          ✅           | 推荐最精确           |
| constructor               |       ✅       |       ✅       |     ✅     |   null/undefined 无   | constructor 可被重写 |
| Array.isArray             |       ❌       |       ❌       |     ✅     |          ❌           | 判断数组首选         |

**实际开发建议：**

- 判断数组用 Array.isArray。
- 判断 null/undefined 用 ===。
- 判断复杂类型用 Object.prototype.toString.call。

#### this 指向问题

1. 普通函数调用

```js
// 谁调用，this 就指向谁（非严格模式下，未指定则为 window；严格模式下为 undefined）
function foo() {
  console.log(this);
}
foo(); // this -> window（浏览器下）
```

2. 方法调用

```js
// 作为对象的方法调用时，this 指向该对象
const obj = {
  foo() {
    console.log(this);
  },
};
obj.foo(); // this -> obj
```

3. 构造函数调用（new）

```js
// 用 new 调用时，this 指向新创建的实例对象
function Person() {
  this.name = "Tom";
}
const p = new Person(); // this -> p
```

4. call/apply/bind 显式绑定

```js
// 用 call/apply/bind 调用时，this 指向第一个参数指定的对象
function foo() {
  console.log(this);
}
foo.call({ x: 1 }); // this -> {x:1}
foo.apply(window); // this -> window
const f = foo.bind({ y: 2 });
f(); // this -> {y:2}
```

5. 箭头函数

```js
// 箭头函数没有自己的 this，继承外层作用域的 this
const obj = {
  foo: () => {
    console.log(this);
  },
};
obj.foo(); // this -> window（或外层作用域的 this）
```

6. 事件处理函数

```js
// DOM 事件中，this 指向当前触发事件的元素
btn.onclick = function () {
  console.log(this);
}; // this -> btn
```

7. 类方法

```js
// 类中的方法，this 指向实例对象
class A {
  show() {
    console.log(this);
  }
}
new A().show(); // this -> 实例对象
```

### 前端技术选型需要考虑哪些方面

1. 项目类型与规模

   - 是企业级、个人项目、后台管理、移动端还是小程序？
   - 规模大还是小，生命周期长还是短。

2. 团队技术栈与人员能力

   - 团队成员熟悉哪些框架和工具？
   - 是否有相关经验，能否快速上手和维护。

3. 生态与社区活跃度

   - 框架/库是否有活跃的社区、丰富的第三方插件、文档完善。
   - 是否容易找到解决方案和技术支持。

4. 性能与兼容性

   - 是否需要兼容低版本浏览器或特殊终端。
   - 框架/工具的性能表现，是否满足业务需求。

5. 可维护性与扩展性

   - 项目后期是否容易维护、扩展、重构。
   - 是否支持模块化、组件化开发。

6. 开发效率与工具链

   - 是否有完善的脚手架、自动化构建、热更新、调试工具。
   - 是否支持 TypeScript、单元测试、CI/CD。

7. 业务需求与技术特性

   - 是否需要 SSR（服务端渲染）、SEO、PWA、移动端适配等。
   - 是否有特殊的交互、动画、数据可视化等需求。

8. 成本与风险

   - 学习成本、迁移成本、维护成本。
   - 技术选型是否有被淘汰或社区衰退的风险。

9. 与后端/其他系统的协作

   - 是否需要与后端、第三方服务、微前端等集成。
   - 是否有跨团队协作需求。

10. 版本迭代与升级策略
    - 框架/库的版本迭代速度，升级是否平滑。
    - 是否有长期维护计划。

**总结：**
前端技术选型要结合项目实际需求、团队能力、生态环境、维护成本等多方面综合考虑，不能只看技术本身的流行度或性能指标。建议多做调研、试用和团队讨论，选出最适合当前项目的技术方案。

#### Service-Worker 的一些补充

1. 如何触发 Service-Worker 更新
   Service-Worker 的 install 触发一定是 sw.js 本身发生了变化，最好的方案是设置一个版本号：const VERSION = 'v3'; // 改个版本号
   并且 后续的 caches.open 的时候 都用这个新的版本号

2. 为什么 caches.delete() 需要 Promise.all？
   caches.delete('v1') // 返回 Promise<boolean>，Promise.all 确保所有的 promise 都完成再结束 event.waitUntil

```js
caches.keys().then((keys) =>
  Promise.all(
    keys.map((key) => {
      if (!cacheWhitelist.includes(key)) {
        // 删除旧缓存 例如 'v1'
        return caches.delete(key);
      }
    })
  )
);
caches.keys()  // ← 第1步：获取所有缓存名称
.then(cacheNames => {  // ← 第2步：拿到缓存名称数组
  // cacheNames = ['v1', 'v2', 'old-cache']
    return Promise.all(  // ← 第3步：等待所有删除操作完成
        cacheNames.map(cacheName => {  // ← 第4步：遍历每个缓存名称，不是当前版本cacheWhitelist，就要删除，进而更新缓存
      // 第一次循环: cacheName = 'v1'
      // 第二次循环: cacheName = 'v2'
      // 第三次循环: cacheName = 'old-cache'

```

用户首次访问 / SW 文件更新
↓
【install】安装阶段 - 缓存资源
↓
等待中...（如果有旧版本 SW 在运行）
↓
【activate】激活阶段 - 清理旧缓存
↓
【fetch】工作阶段 - 拦截网络请求
↓
持续监听...
