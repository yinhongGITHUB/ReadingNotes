主要复习网站：https://vue3js.cn/interview/

#### ES 模块为什么快？

Tree Shaking：由于 ESM 的 import 和 export 语句是静态声明的（即在编译时就可以确定），构建工具可以对模块依赖进行静态分析，从而识别出未使用的导出并移除它们。
它能有效减少最终打包文件的大小，进而加快加载时间。

#### new 的时候做了什么？

1. 创建一个空对象
2. 将构造函数的 this 对象绑定到新创建的空对象（具体如何绑定的呢，新对象的*proto*(原型)指向构造函数的 prototype（原型对象），这里就继承方法，再通过 call/bind/apply 改变构造函数里面的 this 指向，指向该空对象，这里继承属性）

```js
   手动实现一个 new
   function \_new(constructor, ...args) {
   // 1. 新建一个普通对象
   let obj = {};
   // 2. \_new 函数本身是可以接收参数的 但是又不知道具体会接收几个 接收什么参数 故用下面的方法
   // let [constructor, ...args] = [...arguments]; // 解构赋值 constructor 是 构造函数哈哈哈
   // 3. 建立联系 生成的这个对象是 constructor 的实例 需要使用**proto** 和 构造函数的 prototype 建立联系
   obj.**proto** = constructor.prototype;
   // 4. 执行 constructor 构造函数 并且 this 指向 自己新建的对象
   let result = constructor.apply(obj, args);
   // 5. 判断构造函数是否返回的是 对象或者 函数 是的话直接返回这个结果 如果不是 那么返回 自己创建的 obj 对象
   if (result && (typeof (result) == "object" || typeof (result) == "function")) {
   return result;
   }
   return obj;
   }
```

3. 执行构造函数中的代码·
4. 默认情况下，构造函数没有显式的 return 语句，这时 new 表达式会自动返回这个新创建的对象（即 this）。然而，如果构造函数中有显式的 return 语句，并且返回的是一个对象，则返回的将是这个对象而不是新创建的实例。如果返回的是一个原始类型（如数字、字符串等），则忽略该返回值，仍然返回新创建的实例。

#### 原型链的理解

prototype 是原型对象 每个对象下面都有*proto*原型，*proto*原型再指向内置对象 Object，Object 也有*proto*原型，但是是 null

原型链继承，就是构造函数的原型对象指向新的构造函数再 new 一下，缺点：当子级实例化多个对象后，在父级的数据是同一内存空间，会互相影响

试图修改 this 的值是不允许的。this 的值取决于函数的调用方式，而不是可以在函数体内随意改变的变量。

**执行上下文**是一个动态的概念，描述了代码执行的具体环境，包括变量对象、作用域链和 this 绑定等信息。每次函数调用都会创建一个新的执行上下文。
**作用域**是一个静态的概念，描述了变量的可访问性规则。它是根据代码的书写位置来决定的，不会随执行上下文的变化而变化。也就是说，变量的作用域是在编写代码时就确定了的。

#### 动态的柯里化：

```js
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      // 如果收集到的参数数量达到了原函数需要的数量，则直接调用原函数
      return fn.apply(this, args);
    } else {
      // 否则返回一个新的函数，继续收集参数
      return function (...args2) {
        // 将新旧参数合并后递归调用 curried
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

// 使用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 输出: 6
console.log(curriedAdd(1, 2)(3)); // 输出: 6
console.log(curriedAdd(1)(2, 3)); // 输出: 6
console.log(curriedAdd(1, 2, 3)); // 输出: 6
```

#### 事件循环机制

JavaScript 是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环
同步任务在执行栈中立即执行，异步任务在事件队列中，异步任务分为微任务与宏任务
async/await 会阻塞代码运行，等待 await 后面的代码完毕后，下面的代码，会被视作微任务，加入任务队列（事件队列），按顺序执行

```js
async function test() {
  await console.log(1);
}
test();
console.log(2);
// 打印 1 2

async function test() {
  await Promise.resolve().then(() => {
    console.log(1);
  });
}
test();
console.log(2);
// 打印 2 1

async function aa() {
  await Promise.resolve().then(() => {
    console.log(1);
  });
  Promise.resolve().then(() => {
    console.log(4);
  });
}
function bb() {
  Promise.resolve().then(() => {
    console.log(5);
  });
}
aa();
console.log(2);
bb();
// 打印 2 1 5 4
```

跑到 await 时，await 同行的代码是同步代码的，则先执行，假如是异步代码，则根据宏任务微任务，按顺序执行，await 下一行的代码往下都是微任务，如果下一行没代码，则把**函数运行的完成**推到微队列（这个概念很重要）
凡是标记了 async 的函数，返回的都是一个 Promise，凡是看到 await，一定会等待后面的 Promise 完成，如果不是 Promise，则会把数字、对象等按照这种形式返回，Promise.resolve(123)

事件队列（异步任务待的地方）和执行栈（同步任务待的地方）其实是一个“先进先出”的数据结构
执行栈符合先进后出（LIFO）

##### 常见的宏任务：

主代码块
setTimeout 理解：多少秒之后，把一个函数推到宏队列，这就是计时器的作用
setInterval
setImmediate ()-Node
requestAnimationFrame ()-浏览器
DOM 事件回调（如 click、mousemove、mouseenter、mouseleave 等）

##### 常见的微任务：

Promise.then()
catch
finally
Object.observe
MutationObserver

```js
console.log("Script start");

// 宏任务之前的微任务
Promise.resolve().then(() => {
  console.log("Microtask 1");
});

// 宏任务
setTimeout(() => {
  console.log("Macrotask");

  // 宏任务内的微任务
  Promise.resolve().then(() => {
    console.log("Microtask inside Macrotask");
  });
}, 0);

// 宏任务之后的微任务
Promise.resolve().then(() => {
  console.log("Microtask 2");
});

console.log("Script end");
// 结果
// Script start
// Script end
// Microtask 1
// Microtask 2
// Macrotask
// Microtask inside Macrotask
```

很明显，async/await 在的那一行代码，阻塞并立即运行，并且下面的代码都是微任务，放入任务队列（事件队列）按顺序执行

以下是一个简单的例子：

```js
new Promise((resolve, reject) => {
  resolve();
}).then(() => {
  console.log("then1");
});
async function fn1() {
  console.log(1);
  await fn2();
  console.log(2); // 阻塞
}

async function fn2() {
  console.log("fn2");
}

fn1();
console.log(3);
new Promise((resolve, reject) => {
  resolve();
}).then(() => {
  console.log("then2");
});
//1 fn2 3 then1 2 then2
```

以下是一个困难的例子：

```js
async function asy1() {
  console.log(1);
  await asy2();
  console.log(2);
}
const asy2 = async () => {
  await setTimeout(() => {
    Promise.resolve().then(() => {
      console.log(3);
    });
    console.log(4);
  }, 0);
};
const asy3 = async () => {
  Promise.resolve().then(() => {
    console.log(6);
  });
};
asy1();
console.log(7);
asy3();
// 打印 1 7 6 2 4 3

async function asy1() {
  console.log(1);
  await asy2();
  console.log(2);
}
const asy2 = async () => {
  await (async () => {
    await (() => {
      console.log(3);
    })();
    console.log(4); // 关键在于 await 后面的同步代码是立即执行的，只有异步代码才会进任务队列（宏任务、微任务），并且执行完后会将下面的代码，会以微任务的形式进微任务队列 哪怕没有这一行，输出是 // 1 3 7 6 2，执行完 console.log(3)后 将整个函数完成推到微任务，等待确认完成 才会将 上面的 console.log(2);推到微任务
  })();
};
const asy3 = async () => {
  Promise.resolve().then(() => {
    console.log(6);
  });
};
asy1();
console.log(7);
asy3();
// 1 3 7 4 6 2
```

#### 内存泄漏的情况

1. 闭包
2. 全局变量
3. 组合函数（最里层的函数的返回结果作为外面一层的参数，从右到左执行）：通常指的是从右到左的应用函数顺序（尽管有些库可能提供不同的方向）。它适合于当你有一个明确的函数序列需要按特定顺序执行时。
4. 管道函数（从左往右执行）：更多地强调数据流的方向，通常是直观的从左到右。这种方式对于构建可读性强、易于理解的数据处理流水线特别有用。

#### 闭包的理解：

```js
function a(x) {
  function b() {
    console.log(x++);
  }
  return b;
}
a(1)();
a(1)();
a(1)();
a(1); // 形成了多个闭包的缓存空间，只是看不出来 因为没累加

let c = a(1); // 形成了闭包空间，x变量已经缓存起来了，等待后续的调用实现累加
c();
c();
c();
```

闭包是在 a 函数执行的时候才形成的，函数分为三个阶段，声明（即变量提升）定义（即具体的函数体）调用（即开始运行函数体里面的代码）

      c();

#### xss 攻击（跨站脚本攻击）

**XSS攻击类型与原理：**

1. 反射型 XSS：

- 攻击者构造恶意链接，用户点击后，恶意脚本被服务端“反射”到响应中并执行。
- 典型场景：搜索、跳转等接口直接把用户输入拼到页面上。
- 需要用户主动点击链接。

2. 存储型 XSS：

- 恶意脚本被存储在服务端数据库（如评论、昵称等），所有访问该页面的用户都会被攻击。
- 典型场景：论坛、留言板、用户资料等。
- 一次注入，长期生效。

3. DOM型 XSS：

- 恶意脚本通过前端 JS 操作 DOM 注入（如 location.hash、document.write），无需服务端参与。
- 典型场景：前端直接用用户输入拼接 innerHTML、eval、document.write 等。

**XSS攻击方式：**

- 注入恶意 JS 代码，窃取 Cookie、Session、用户信息。
- 伪造页面、钓鱼、强制跳转、传播蠕虫病毒。

**XSS防御措施：**

1. 对所有用户输入进行严格过滤和转义（如 <、>、"、'、/ 等特殊字符）。
2. 输出内容时进行 HTML 实体编码。
3. 使用 CSP（内容安全策略）限制脚本来源。
4. 禁止内联 JS、禁止 eval、document.write 等危险操作。
5. 设置 HttpOnly Cookie，防止 JS 读取敏感信息。
6. 前后端都要做输入校验和输出转义。

#### csrf 攻击（跨站请求伪造）

**CSRF攻击原理：**

- 攻击者诱导用户访问第三方恶意网站，利用用户已登录状态，自动向目标网站发起请求（如转账、修改资料等）。
- 由于浏览器会自动携带 Cookie，目标网站误以为是用户本人操作。

**CSRF攻击方式：**

1. GET 请求伪造：恶意网站嵌入图片、a标签、script等，自动发起 GET 请求。
2. POST 请求伪造：通过隐藏表单、自动提交等方式发起 POST 请求。
3. 结合 XSS，窃取用户身份信息。

**CSRF防御措施：**

1. 验证码（如转账、敏感操作时要求输入验证码）。
2. CSRF Token（每次请求携带唯一 Token，服务端校验）。
3. SameSite Cookie（设置 Cookie 的 SameSite 属性，限制第三方网站携带 Cookie）。
4. 用户敏感操作时要求重新登录或二次验证。
5. 对 Referer、Origin 头进行校验。

#### css 选择器优先级排序

!important > 行内样式 > ID 选择器 > 类选择器 | 属性选择器 | 伪类选择器 > 标签选择器 | 伪元素选择器 > 通配符 > 继承 > 浏览器默认属性
注意：伪类选择器 :nth-child(n) 是从 1 开始的 不是从 0 开始的，n 是几，就是第几个子标签

#### 设备像素比（DPR）

DPR = 1：每个 CSS 像素对应一个物理像素（也叫设备像素）。
DPR = 2：每个 CSS 像素对应四个物理像素（也叫设备像素）（2x2 网格）。
DPR = 3：每个 CSS 像素对应九个物理像素（也叫设备像素）（3x3 网格）。
实际分辨率（也叫设备像素）：指的是屏幕上的总物理像素数。例如，一部 iPhone 12 的分辨率为 1170px x 2532px。
一个 px 就是每个 CSS 像素（也叫设备独立像素）
ppi （pixel per inch），每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像
设备像素比（dpr） = 设备像素 / 设备独立像素
每英寸物理像素密度（ppi），值越大，图像越清晰

#### bfc 可以清除浮动、防止 margin 塌陷、更好的控制布局

注意：浮动只脱离了文档流，没有脱离文本流，文本还是会给浮动元素腾位置的

#### flex 的三个参数

1. flex-grow：等分剩余空间的比例，平时用的 flex:1
2. flex-shrink：弹性盒子在空间不足时的收缩比例。

- 作用：当父容器空间不足时，子项会按照 flex-shrink 的比例进行缩小。
- 默认值：1（允许收缩）
- 设为 0：不收缩，无论空间多小都保持原始宽度。
- 设为 n：收缩速度是设为 1 的 n 倍。

举例：
假设有两个子项，A 的 flex-shrink: 1，B 的 flex-shrink: 2。
当父容器空间不足时，B 收缩的宽度是 A 的 2 倍。

3. flex-basis：定义了在分配剩余空间之前，弹性项目的基础大小。它可以设置为具体的长度值（如 px, em 等），也可以是百分比或者关键字 auto。auto 表示使用元素的默认尺寸或由内容决定的尺寸。

#### 内容变化也会触发重排

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列
当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 offsetTop 等方法都会返回最新的数据
因此浏览器不得不清空队列，触发回流重绘来返回正确的值

##### 减少重绘重排的方法：

1. 批量修改样式
2. 最小化布局的读写操作，因为每次获取 offsetTop 等方法，都会强制队列重排重绘，所以尽可能地一次性获取全部的，存起来
3. 使用 transform 和 opacity 进行动画，GPU 加速，避免重排/重绘因为他们不会影响元素的位置，不会发生重排，只会发生重绘，
   不能被 GPU 加速的属性（例如 width, height, top, left, margin 等），则可能会导致频繁的重排和重绘，降低动画的流畅度。
4. 避免不必要的复杂选择器，因为层级过深，计算成本高，会造成性能问题，可维护性也差，层级过深，想要覆盖之前的样式，又得写一堆
5. 减少真实 DOM 的操作

强制使用 GPU 加速： transform: translateZ(0); /_ 强制 GPU 加速 _/
即使只是二维变换，也可以通过添加一个 3D 变换属性来提示浏览器使用 GPU 加速。

#### 从用户在地址栏输入 url 到页面展示 这中间发生了什么？

1. URL 解析：
   浏览器首先解析输入的内容，判断它是否是一个有效的 URL 或者是一个搜索查询。根据域名找到对应的 ip
2. DNS 查询：
   如果是 URL，浏览器会检查域名系统（DNS）以获取与该域名相关的 IP 地址。这一步可能涉及到缓存查找、递归 DNS 查询等。
3. 建立 TCP 连接：
   使用获得的 IP 地址，浏览器尝试通过传输控制协议（TCP）与服务器建立连接。这个过程包括三次握手（SYN, SYN-ACK, ACK）。
4. TLS 握手（如果使用 HTTPS）：
   如果网站使用 HTTPS，浏览器和服务器之间还需要进行一次安全层的握手，确保通信的安全性。这涉及证书验证、密钥交换等步骤。
5. 发送 HTTP 请求：
   一旦建立了安全连接，浏览器会发送 HTTP 请求到服务器，请求包含必要的头部信息，如请求类型（GET/POST）、路径、Cookie 等。
6. 服务器处理请求：
   服务器接收到请求后，根据请求的内容做出响应。对于静态文件，服务器直接返回文件；对于动态内容，服务器可能会运行脚本生成 HTML。
7. 接收 HTTP 响应：
   浏览器接收到服务器的响应，其中包含了状态码、头部信息和响应体。响应体通常是 HTML 文档。
8. HTML 解析：
   浏览器开始解析 HTML 文档，构建 DOM 树。在这个过程中，如果遇到外部资源（如 CSS 文件、JavaScript 文件、图片等），浏览器也会发起相应的请求下载这些资源。
9. CSSOM 构建：
   同时，浏览器还会解析 CSS 文件，构建 CSS 对象模型（CSSOM）。CSSOM 和 DOM 结合起来用于计算每个节点的样式。
10. 渲染树构建：
    将 DOM 和 CSSOM 结合起来形成渲染树，只包含需要显示在页面上的节点及其样式信息。
11. 布局 layout：
    计算每个节点在屏幕上的确切大小和位置。
12. 绘制：
    最终，浏览器将渲染树中的节点转换为屏幕上的像素，完成页面的绘制。（GPU 能够快速处理图像和视频数据的处理器）
13. JavaScript 执行：
    如果页面中有 JavaScript 脚本，它们会在适当的时机被执行，可能会修改 DOM 和 CSSOM，触发重新布局或重绘。

**跨域**: 协议、域名、端口三者有一者不一样 都算
**web 服务器**：Apache，有很多处理引擎，例如：针对 php 的 html 的处理引擎

#### 进程 线程

-进程是操作系统对正在运行中的程序进行资源分配和调度的基本单位，一般由程序、数据集合和进程控制块三部分组成：
程序用于描述进程要完成的功能，是控制进程执行的指令集
数据集合是程序在执行时所需要的数据和工作区
程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志

- 线程是进程内的一个执行单元，也是进程内的实际运作单位，负责当前进程中程序的执行，操作系统能够进行运算调度的最小单位
  一个线程在同一进程中可以有多个兄弟线程，它们共享进程的资源，同进程的线程资源共享，不同的就无法共享了
  iframe 会引发性能问题：

#### iframe 相关

1. 额外的 HTTP 请求：每个 <iframe> 都会发起一个独立的 HTTP(S)请求来获取其内容。这意味着如果页面中有多个 <iframe>，浏览器需要同时处理更多的网络请求，这可能会显著增加总的加载时间。
2. 资源竞争：当页面包含 <iframe> 时，浏览器需要为该 <iframe> 分配资源（如内存、CPU 等），这可能会减少可用于主页面加载和渲染的资源量，尤其是在资源有限的情况
3. 阻塞行为：默认情况下，<iframe> 的加载是同步的，即浏览器会等待 <iframe> 内容完全加载后才会继续执行后续操作，如果 <iframe>含有或依赖于 JavaScript 文件，而这些 js 文件正好阻塞了代码（即有个请求时间很长的请求），就会影响页面其他部分的加载
4. 重排和重绘：<iframe> 不指定大小，会触发额外的重排和重绘

##### 如何减轻 <iframe> 对页面加载的影响：

1. 懒加载：使用 loading="lazy" 属性
   <img src="example.jpg" loading="lazy" alt="示例图片">
2. 明确尺寸
3. 异步加载 <iframe> 标签引用页面的 js 脚本，async 和 defer 属性用于 <script> 标签上，它们的目的恰恰是为了避免阻塞页面的解析。（<script src="example.js" async></script> <script src="example.js" defer></script>）

async 属性：一旦脚本下载完成，浏览器将立即中断 HTML 解析来执行这个脚本。
defer 属性：会在整个 HTML 文档完全解析完成后但在 DOMContentLoaded 事件触发之前执行，操作 dom 的脚本适合用这个。

#### 正向代理（Forward Proxy）

正向代理通常用于保护客户端隐私或突破网络限制。它位于客户端和目标服务器之间，代表客户端发起对外部资源的请求。这种情况下，**服务器不知道访问者是谁！！！**
例子：假设你在中国，想要访问被封锁的 Facebook 网站。你可以配置你的浏览器使用一个位于美国的正向代理服务器。当你尝试访问 Facebook 时，实际上是你的请求先发送到这个美国的代理服务器，然后由该代理服务器转发请求并接收响应，再将结果返回给你。

#### 反向代理（Reverse Proxy）

反向代理则主要用于保护内部网络的安全性、负载均衡等目的。它位于客户端和一组内部服务器之间，代表内部服务器处理来自外部客户端的请求。这种情况下，**客户端不知道自己访问的真正地址！！！**
例子：考虑一个大型网站如淘宝，它可能有成百上千台服务器来处理用户的请求。但是，用户并不直接访问这些服务器中的某一台，而是通过一个反向代理服务器来分发请求。这个反向代理根据一定的策略（比如负载均衡算法）选择合适的后台服务器来处理每个请求，并将结果返回给用户。这样做的好处包括提高安全性、隐藏实际服务端架构以及优化资源利用等。

#### 反向代理可能遇到的问题：

1. WebSocket 支持：默认情况下，Nginx 对 WebSocket 的支持需要额外配置。
2. 性能问题：如果后端服务器响应缓慢，可能会导致客户端等待时间增加。
3. 安全问题：不当的配置可能导致内部网络暴露给外部攻击者，因此必须仔细配置访问控制和验证机制。
4. 缓存问题：如果后端内容频繁变化但 Nginx 缓存策略设置不合理，可能会导致用户看到过期数据。
5. 错误处理：需要妥善处理后端服务器返回的各种错误状态码，并正确地将它们传递给客户端。还有路由问题，都不在 nginx 里面处理，都交给前端的路由。
   root /data/dist;
   index index.html;

   location / {
   try_files $uri $uri/ /index.html;
   }

先配置一个 index 的路径，在配置不管什么 url，都重定向到 index 下面去

##### 服务端渲染：

一般只有首页需要 ssr，那么首页的路由配置那里就不再是
{
path:'/',
name: 'index',
component: () => import('@/page/home/Home.vue'),
}
而是：
import App from './App.vue';
{
path: '/',
component: App
},
首页的组件不再是一个组件继续依靠路由规则放在 index.html 的 <main id="app"></main>，而是去请求 App.vue，从而触发服务端渲染
当访问首页 / 的时候，server.ts 所监听的 app.get("/")便会触发

```js
// server.ts
import express from "express";
import { createSSRApp } from "vue";
import { renderToString } from "@vue/server-renderer";
import App from "../client/App.vue";
import fs from "fs";
import path from "path";

const app = express();
const PORT = process.env.PORT || 3000;

// 处理根路径请求，进行 SSR
app.get("/", async (req, res) => {
  const vueApp = createSSRApp(App);
  const appHtml = await renderToString(vueApp);
  const indexHtml = fs.readFileSync(
    path.resolve(__dirname, "../index.html"),
    "utf-8",
  );
  const html = indexHtml.replace(
    '<div id="app"></div>',
    `<div id="app">${appHtml}</div>`,
  );
  res.send(html);
});

// 处理其他路径请求，返回静态 HTML
app.get("*", (req, res) => {
  const indexHtml = fs.readFileSync(
    path.resolve(__dirname, "../index.html"),
    "utf-8",
  );
  res.send(indexHtml);
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

#### 抓包

Wireshark，可以通过 ip.src 输入 ip，过滤指定的 http 数据包

#### 纯函数

优点：

1. 可预测性：同样的输入，给出的都是同样的输出
2. 易于调试：不依赖外部环境或变量
3. 并行 / 并发安全：不依赖共享状态，无需锁机制，可在多线程 / Worker 中安全并行执行
4. 可维护性：依赖关系完全通过参数显式表达，避免了对全局状态的隐式依赖，使代码更易于理解和重构

缺点：

1. 重复计算：对于相同的输入，它会始终返回相同的结果。这可能导致在某些情况下出现重复计算，浪费计算资源和时间
2. 难以优化：一些在有副作用的函数中容易实现的优化，在纯函数中可能会变得困难。因为纯函数的不可变性和独立性，使得编译器或解释器难以进行某些全局优化，例如，无法通过修改共享状态来避免不必要的计算
3. 难以处理复杂业务逻辑：修改外部状态或依赖于外部环境，使用纯函数来实现可能会非常复杂，甚至难以实现
4. 状态管理复杂：由于纯函数本身不能直接修改外部状态，因此需要通过传递状态对象或使用其他方式来模拟状态变化，这可能会增加代码的复杂性和维护成本

#### 如何防止尾递归 内存溢出

1. 转为迭代的方式，就是将递归逻辑改写为循环结构（for (let i = 2; i <= n; i++)）
2. 手动实现尾递归优化（Trampoline 模式）
   通过 ** 蹦床函数（Trampoline）** 将递归转换为循环执行，每次递归调用返回一个函数而非直接执行

```js
// 原始尾递归函数（未优化）
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  return sum(n - 1, acc + n); // 普通递归调用
}

// 优化：返回待执行的函数而非直接递归
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  return () => sum(n - 1, acc + n); // 返回函数
}

// 蹦床函数：循环执行返回的函数直到得到结果
function trampoline(fn) {
  return function (...args) {
    let result = fn(...args);
    while (typeof result === "function") {
      result = result();
    }
    return result;
  };
}

// 使用蹦床函数包装原始函数
const safeSum = trampoline(sum);
console.log(safeSum(100000)); // 不会栈溢出
```

3. 使用生成器,每次都得 next 一下，避免一次调用很多次

#### ts 抽象类和抽象方法

```js
abstract class Shape {
abstract getArea(): number; // 抽象方法，必须由子类实现
}
//不光抽象类 接口也是
interface Drawable {
    draw(): void; // 接口要求必须实现 draw() 方法
}

class Circle implements Drawable {
    // 错误：未实现 draw() 方法
}

const circle: Drawable = new Circle(); // 编译错误！
```

#### lighthouse 衡量网站性能指标是什么

1. 加载性能指标
   FCP (First Contentful Paint)
   定义：首次有内容（文本、图片、SVG 等）渲染到屏幕的时间。
   意义：衡量页面的初始加载速度，反映用户感知到的 “页面开始加载” 时间。
   目标：在 1.8 秒 内完成（移动端）。
   LCP (Largest Contentful Paint)
   定义：视口中最大可见元素（如图片、视频或文本块）完成渲染的时间。
   意义：衡量主要内容的加载速度，是用户感知页面 “可用” 的关键指标。
   目标：在 2.5 秒 内完成（移动端）。
2. 交互性指标
   FID (First Input Delay)
   定义：用户首次与页面交互（如点击按钮）到浏览器实际响应的时间延迟。
   意义：衡量页面的响应能力，延迟过长会让用户感到卡顿。
   目标：小于 100 毫秒（移动端）。
   TTI (Time to Interactive)
   定义：页面完全可交互的时间点（所有资源加载完成，能够快速响应操作）。
   意义：衡量页面从 “加载中” 到 “可使用” 的转变速度。
   目标：在 3.8 秒 内完成（移动端）。
3. 视觉稳定性指标
   CLS (Cumulative Layout Shift)
   定义：页面加载过程中，元素位置突然变化的累积度量（布局偏移分数）。
   意义：衡量页面内容的视觉稳定性，避免意外的布局变动干扰用户操作。
   目标：小于 0.1（分数越低越好）。
4. 其他 Lighthouse 指标
   SI (Speed Index)
   定义：页面内容逐步渲染的速度，通过计算可见区域填充的平均时间得出。
   意义：评估整体加载体验的流畅度。
   目标：在 4.0 秒 内完成（移动端）。
   TBT (Total Blocking Time)
   定义：FCP 到 TTI 之间，主线程被阻塞无法响应用户输入的总时间。
   意义：衡量页面在加载过程中的无响应程度。
   目标：小于 300 毫秒（移动端）。

报告解读示例
Lighthouse 会为每个指标给出 0-100 的分数：

绿色（90-100）：良好
黄色（50-89）：需要改进
红色（0-49）：性能较差

#### 把一个一维数组 list 变成树状结构

```js
// 假设 list 是 [{id: 1, parentId: null}, {id: 2, parentId: 1}, ...]
const idMap = new Map();
const result = [];

list.forEach((item) => {
  idMap.set(item.id, { ...item, children: [] });
});

list.forEach((item) => {
  const node = idMap.get(item.id);
  if (!item.parentId) {
    result.push(node);
  } else {
    const parent = idMap.get(item.parentId);
    if (parent) {
      parent.children.push(node);
    }
  }
});
```
