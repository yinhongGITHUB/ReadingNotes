#### 常见的 HTTP 状态码

- 1xx 信息响应

100 Continue：初步请求已接受，需继续发送请求  
101 Switching Protocols：服务器切换协议

- 2xx 成功

200 OK：请求成功  
201 Created：已创建新资源  
202 Accepted：请求已接受但未处理完成  
204 No Content：无内容  
206 Partial Content：部分内容（断点续传）

- 3xx 重定向

301 Moved Permanently：永久重定向  
302 Found：临时重定向  
303 See Other：表示请求资源已被临时移动到另一个 URI，客户端应使用 GET 方法访问新的 URI，常用于 POST 请求后重定向到结果页面。会在响应头中使用 Location 字段指定新的 URL
304 Not Modified：未修改  
307 Temporary Redirect：临时重定向
308 Permanent Redirect：永久重定向  
308 Permanent Redirect：永久重定向

**【302 和 307 的区别】**
302 Found：临时重定向，早期标准未规定重定向后请求方法是否改变，部分浏览器会将 POST 变为 GET。
307 Temporary Redirect：临时重定向，明确要求重定向后请求方法和请求体不变，严格遵循原请求方式。

- 4xx 客户端错误

400 Bad Request：请求语法错误  
401 Unauthorized：未授权  
403 Forbidden：禁止访问  
404 Not Found：未找到资源  
405 Method Not Allowed：方法不允许  
408 Request Timeout：请求超时  
409 Conflict：资源冲突  
413 Payload Too Large：请求体过大  
414 URI Too Long：URI 过长  
415 Unsupported Media Type：不支持的媒体类型  
429 Too Many Requests：请求过多

- 5xx 服务端错误

500 Internal Server Error：服务器内部错误  
501 Not Implemented：未实现  
502 Bad Gateway：网关错误  
503 Service Unavailable：服务不可用  
504 Gateway Timeout：网关超时  
505 HTTP Version Not Supported：不支持的 HTTP 版本

#### https 的加密过程

**非对称加密**：公钥和私钥，公钥私钥都可用来加密，公钥加密必须私钥解密，反之亦然  
**对称加密**：解密加密都用同一个密钥
服务器先把公钥和 CA 证书明文发给浏览器，CA 证书里面的证书信息和数字签名可以证明，这个公钥确实来自于服务器，（注意：CA 证书是采用的是非对称加密，所有浏览器自动保存 CA 的公钥，CA 的公钥通常是预先安装在浏览器或操作系统中的）
浏览器将生成对称加密的密钥，将新增对称加密。然后将对称加密的密钥和加密后的信息用公钥加密，一起发给服务端

#### 项目中文件缓存机制

#### 强缓存：

JS、CSS、图片等静态资源，减少请求，提升加载速度
用户再次访问网站：
浏览器请求最新的 index.html，发现 JS 引用路径变为 app.a1b2c3.js。
浏览器认为这是新资源，发起新请求，获取最新 JS 文件。

#### 协商缓存：

index.html、API 响应 ，确保内容实时更新

#### 浏览器缓存

##### 强制缓存

Cache-Control（响应、请求带的）（max-age=3600 时间段）、Expires（响应、请求带的）（GMT 时间，浏览器那边的时区可能导致不准确）

##### 协商缓存：

开启的时机 Cache-Control：no-cache 实际上是用来开启协商缓存的
Etag（响应带的）（服务端给浏览器） / If-None-Match（请求带的）（浏览器带着这个参数，里面放着 Etag 的标识，给服务端，比较是否一致）
Last-Modified（响应带的）（服务器给浏览器，最后的修改时间） / If-Modified-Since（请求带的）（浏览器带着这个参数，给服务端，GMT 时间，精确到秒级，秒以下的修改无法检测到）

#### 三次握手的过程：

SYN：表示这是一个同步报文段，用来发起一个新的连接。
ACK：表示这是一个确认报文段，用来确认已经收到了对方的某个报文段。
第一次握手（SYN）：
客户端到服务器：客户端发送一个带有 SYN（Synchronize Sequence Numbers，同步序列编号）标志的数据包给服务器，表示希望与服务器建立连接。在这个数据包中，客户端会随机选择一个初始序列号（假设为 x），并将其包含在数据包中。
状态变化：客户端从 CLOSED 状态进入 SYN_SENT 状态，等待服务器确认。
第二次握手（SYN-ACK）：
服务器到客户端：一旦服务器接收到客户端的 SYN 请求，它将响应一个同时带有 SYN 和 ACK（Acknowledgment，确认字符）标志的数据包。服务器也会生成自己的初始序列号（假设为 y），并且在 ACK 字段中使用 x+1 来确认收到了客户端的 SYN 请求（即确认客户端的初始序列号加 1），这两个序列号都会放在 SYN+ACK 包中。
状态变化：服务器从 LISTEN 状态进入 SYN_RCVD 状态，表明已经收到了客户端的连接请求，并且也发出了自己的连接请求。
第三次握手（ACK）：
客户端到服务器：客户端接收到服务器的 SYN-ACK 响应后，需要再次发送一个 ACK 数据包作为回应。在这个数据包中，客户端会在 ACK 字段中使用 y+1 来确认收到了服务器的 SYN 请求。此时，双方的初始序列号都得到了对方的认可。
状态变化：客户端从 SYN_SENT 状态进入 ESTABLISHED 状态，表示连接已经建立；当服务器收到这个 ACK 后，也会从 SYN_RCVD 状态进入 ESTABLISHED 状态。
完成三次握手后的状态
完成上述三次握手后，客户端和服务端都认为连接已经成功建立，并且双方都知道彼此的初始序列号，这样就可以开始进行数据传输了。这种机制确保了双方都能确认对方的存在，并准备好接收数据，同时也提供了一种方式来初始化序列号，这对于保证数据包按顺序到达以及检测丢失的数据包至关重要。

#### 为什么需要三次握手？

同步序列号：确保双方都知道对方的初始序列号，这对于维护数据流的顺序和完整性非常重要。
防止重复连接：如果网络中存在旧的、过期的连接请求报文段，三次握手可以帮助避免基于这些报文段建立错误的连接。
确认双方的可用性：为了稳定的传输数据，确定双方的接收和发送能力是正常的，确保客户端和服务器都处于工作状态，并准备好进行通信。

#### 四次挥手的过程

第一次挥手：主动关闭方（通常是客户端）发送一个带有 FIN 标志的 TCP 报文段给被动关闭方（通常是服务器），表示自己已经没有数据要发送了，但仍然可以接收数据。此时，主动关闭方进入 FIN_WAIT_1 状态。
第二次挥手：被动关闭方收到 FIN 报文后，会发送一个 ACK 报文作为响应，确认序号为收到的 FIN 报文的序号加 1。这时，被动关闭方进入 CLOSE_WAIT 状态，而主动关闭方收到这个 ACK 后进入 FIN_WAIT_2 状态。注意，这里只是单方面结束了从主动关闭方向被动关闭方的数据流。
第三次挥手：当被动关闭方也没有数据要发送的时候，它会发送一个 FIN 报文给主动关闭方，请求关闭从被动关闭方向主动关闭方的数据流。此时，被动关闭方进入 LAST_ACK 状态。
第四次挥手：主动关闭方收到 FIN 报文后，发送一个 ACK 报文作为响应，并进入 TIME_WAIT 状态。被动关闭方收到这个 ACK 后即关闭连接。在 TIME_WAIT 状态下，主动关闭方等待一段足够长的时间（通常是最大报文生成时间的两倍，即 2MSL，MSL 为 Maximum Segment Lifetime）以确保被动关闭方收到了 ACK 报文，然后才彻底关闭连接。
为什么需要四次挥手？
双向通信的需求：由于 TCP 连接是全双工的，这意味着每个方向上的数据传输都需要单独关闭。一次挥手只能关闭一个方向的数据传输。
确保数据完整传输：在第一步中，主动关闭方发送 FIN 报文表明它不再有数据发送，但它仍然可以接收数据。被动关闭方可能还有未发送完的数据需要传送给主动关闭方，所以它不能立即发送 FIN，而是先发送 ACK 确认收到对方的 FIN，之后再决定何时发送自己的 FIN。
TIME_WAIT 状态的重要性(重传机制)：最后一个 ACK 是由主动关闭方发送的，如果这个 ACK 丢失了，被动关闭方将无法正常关闭连接。因此，主动关闭方需要停留在 TIME_WAIT 状态一段时间，以便在必要时重发 ACK 报文。这段时间也允许网络中的任何延迟或重复的分段消失。

#### HTTP 是一个属于应用层的面向对象的协议

##### HTTP 协议一共有五大特点：

1. 支持客户/服务器模式；
2. 简单快速；
3. 灵活；
4. 无连接；
5. 无状态

##### HTTP/0.9 (1991)

简介：这是 HTTP 的第一个版本，非常简单，只支持 GET 方法。
特性：
仅支持纯文本内容。
没有响应头，只有 HTML 格式的数据。
不支持持久连接，每次请求都需要建立一个新的 TCP 连接。

##### HTTP/1.0 (1996)

简介：引入了许多重要的功能，成为第一个被广泛使用的 HTTP 版本。
特性：
支持多种 HTTP 方法，如 GET、POST、HEAD 等。
引入了响应头，允许服务器向客户端发送元数据（例如内容类型、状态码等）。
支持多种媒体类型，不只是纯文本。
尽管支持了更多的功能，但默认情况下仍不支持持久连接。

##### HTTP/1.1 (1999)

简介：HTTP/1.1 是对 HTTP/1.0 的重大改进，至今仍然是最常用的 HTTP 版本之一。
特性：
持久连接（Persistent Connections）：通过 Connection: keep-alive 头部支持，减少了建立和断开 TCP 连接的开销。
管道化（Pipelining）：允许多个请求同时在一个连接中排队发送，理论上可以提高效率，但实际上并未得到广泛应用。
分块传输编码（Chunked Transfer Encoding）：支持动态生成的内容在未完全准备好时就开始传输。
虚拟主机（Virtual Hosting）：允许一个服务器托管多个域名，通过 Host 头部区分不同的站点。
缓存机制增强：包括 Cache-Control, ETag, If-None-Match 等头部，提供了更灵活的缓存控制。
范围请求（Range Requests）：允许客户端请求资源的部分内容，适用于大文件下载或断点续传。

##### HTTP/2 (2015)

简介：基于 SPDY 协议开发，旨在解决 HTTP/1.1 的一些性能瓶颈。
特性：
多路复用（Multiplexing）：允许在同一连接上并行发送多个请求和响应，解决了队头阻塞问题。
头部压缩（Header Compression）：使用 HPACK 算法压缩 HTTP 头部，减少传输数据量。
服务器推送（Server Push）：允许服务器主动向客户端推送资源，无需等待客户端请求。
二进制协议：相比于 HTTP/1.x 的文本协议，HTTP/2 采用二进制协议，提高了解析效率和安全性。
流优先级（Stream Prioritization）：允许客户端指定哪些请求更重要，优化加载顺序。

##### HTTP/3 (2022)

简介：基于 QUIC 协议构建，旨在进一步改善性能和可靠性，特别是针对高延迟或不稳定网络环境。
特性：
基于 UDP 的 QUIC 协议：不同于传统的基于 TCP 的实现，QUIC 协议提供更快的连接建立时间和更好的错误恢复能力。
内置加密：与 TLS 1.3 深度集成，所有 HTTP/3 流量默认加密，增强了隐私保护。
连接迁移（Connection Migration）：即使 IP 地址发生变化（例如从 Wi-Fi 切换到移动数据），也能保持连接不断开。
低延迟连接建立：相比 TCP+TLS，QUIC 能够以更低的延迟建立安全连接。

#### 浏览器的字节码缓存

浏览器的字节码缓存是现代浏览器采用的一种性能优化手段，其主要目的是加快 JavaScript 代码的执行速度。下面将详细介绍其原理、不同浏览器的实现方式以及实际应用中的注意要点。
一、基本原理
JavaScript 是一种解释型语言，传统的执行流程是：源代码先被解析（Parse）为抽象语法树（AST），接着再用 lgnition 编译成字节码（Bytecode），最后由解释器执行。为了提升执行速度，现代浏览器引入了 JIT（即时编译）技术，它会把热点代码编译成机器码。

字节码缓存的工作原理是：浏览器在首次加载并编译 JavaScript 后，会将生成的字节码（甚至是机器码）存储在本地。当同一脚本再次被加载时，浏览器可以直接读取缓存的字节码，跳过解析和初始编译阶段，从而大幅缩短脚本的启动时间。

如：Chrome（V8 引擎）
Chrome 使用 Code Cache 技术，该技术会把编译后的字节码存储在用户本地的磁盘中。其特点如下：

只有通过 HTTPS 或者 localhost 加载的脚本才会被缓存。
缓存的有效期与脚本的内容哈希值相关联，当脚本内容发生变化时，缓存会自动失效。
可以通过浏览器的 DevTools 中的 Application → Cache Storage 查看缓存情况。

#### 为什么需要 AST？

抽象语法树（Abstract Syntax Tree，AST） 是源代码语法结构的一种抽象表示。它以树状形式展示代码的语法结构，每个节点代表源代码中的一个语法元素，节点之间的关系反映了语法的嵌套结构。
（其实就是一个 json 对象）

- 代码分析：通过遍历 AST 可以实现代码检查（如 ESLint 规则校验）、依赖收集（如 Webpack 分析 import 语句）。
- 代码转换：修改 AST 后重新生成代码，实现编译（如 TypeScript → JavaScript）、代码压缩（如 UglifyJS 删除未使用代码）。
- 跨语言编译：将一种语言的 AST 转换为另一种语言的 AST（如 JSX → React.createElement）。

#### 哪些情况会触发预检

只有跨域请求时，非简单方法（如 PUT/DELETE）或 Content-Type 为非简单类型（如 application/json）才会触发预检（OPTIONS）。如果是**同源请求，无论方法或 Content-Type 如何，都不会有预检**。预检的本质是浏览器为了安全，在跨域时先询问服务器是否允许这类请求。

前提是 **跨域**

1. Content-Type 非简单类型（如 application/json），需预检确认服务器支持。
   简单的 Content-Type 取值只有三种：
   text/plain
   multipart/form-data
   application/x-www-form-urlencoded
   其它类型（如 application/json）都属于“非简单 Content-Type”。

2. headers: {
   'X-User-ID': '12345',
   'Accept': 'application/json'
   }X-User-ID 是自定义头部，不属于简单头部集合，需预检确认服务器允许该头部。 3. 携带 Cookie（withCredentials: true） 的跨域请求需服务器明确允许（Access-Control-Allow-Credentials: true），且 Content-Type 非简单类型，双重条件触发预检。 4. 请求方法非简单方法：
   非简单方法包括：

- PUT：用于更新资源（幂等，重复多次结果一样）。
- DELETE：用于删除资源（幂等，重复多次结果一样）。
- PATCH：用于部分更新资源（非幂等，每次可能结果不同，区别于 PUT 的整体替换）。
- OPTIONS：用于获取服务器支持的通信选项，常用于 CORS 预检，不会对资源产生实际操作。
- CONNECT：用于建立隧道（如 HTTPS 代理），常见于代理服务器，普通 Web 场景很少用。
- TRACE：用于回显收到的请求，主要用于诊断和测试，安全原因一般被禁用。

【PUT vs PATCH】
PUT 是整体替换资源，PATCH 是部分更新资源。PUT 幂等，PATCH 通常非幂等。

#### 预检 的本质

浏览器为了安全，在跨域请求包含非简单方法、非简单头部或非简单 Content-Type 时，会先自动发送一个 OPTIONS 请求，询问服务器是否允许真正的跨域请求。只有服务器明确响应允许，浏览器才会继续发起实际请求。这样可以防止恶意网站随意对其他域名发起敏感操作，保护服务器和用户的数据安全。

**幂等（Idempotent）是指无论对同一个资源执行一次操作还是多次操作，结果都是一样的，不会因为多次执行而产生副作用或不同的结果**

【DELETE vs PUT】
DELETE 用于删除，PUT 用于新增或整体替换，两者都幂等。

【GET vs HEAD】
GET 用于请求获取资源内容，服务器会返回资源的具体内容（如 HTML、JSON、图片等）；HEAD 也是请求资源，但只返回响应头部，不返回具体内容。HEAD 常用于只想获取资源的元信息（如内容长度、类型、最后修改时间等），而不需要下载整个资源本身。两者都不会对资源产生副作用，且都是幂等的。

【OPTIONS vs TRACE】
OPTIONS 用于探测服务器支持的方法，TRACE 用于回显请求内容，主要用于调试。

（简单方法仅 GET、POST、HEAD，GET/HEAD 幂等，POST 非幂等）。触发预检。

#### OSI 七层：

1. 应用层（Application Layer）
   功能：提供应用程序之间的通信。
   描述：这是用户直接接触的一层，支持各种网络应用软件。例如，HTTP、FTP、SMTP 等协议工作在此层，为用户提供文件传输、电子邮件发送等功能。WebSocket 也在这一层
2. 表示层（Presentation Layer）
   功能：数据格式转换、加密解密。
   描述：负责数据的表现形式，包括数据的编码、加密和压缩。这一层确保数据能够以一种可被接收方理解的形式呈现。
3. 会话层（Session Layer）
   功能：建立、管理和终止会话。
   描述：管理不同机器上的用户或应用程序之间的对话控制。例如，设置检查点以便在网络中断时恢复会话。
4. 传输层（Transport Layer）
   功能：提供端到端的数据传输服务。
   描述：保证数据完整地从一个节点传送到另一个节点。TCP 和 UDP 是此层最著名的协议，其中 TCP 提供可靠的连接导向服务，而 UDP 则提供无连接的服务。
5. 网络层（Network Layer）
   功能：路由选择和数据包转发。
   描述：决定数据如何从源地址到达目的地址。IP 协议位于这一层，负责寻址和路径选择。
6. 数据链路层（Data Link Layer）
   功能：物理地址识别及错误检测。
   描述：处理物理层和网络层之间的通信。它将网络层的数据封装成帧，并通过 MAC 地址在局域网中传送这些帧。此外，还负责检测并纠正物理层可能产生的错误。
7. 物理层（Physical Layer）
   功能：定义电气、机械、过程和功能规范。
   描述：涉及实际的物理连接，如电缆类型、信号电压水平、同步信号等。它是 OSI 模型中最底层，直接与传输介质交互
