## JavaScript 正则表达式入门

### 1. 什么是正则表达式？

正则表达式（RegExp）是一种用来匹配字符串中字符组合的工具，常用于查找、替换、验证等场景。

### 2. 创建正则表达式

- 字面量方式：`let reg = /abc/;`
- 构造函数方式：`let reg = new RegExp('abc');`

### 3. 常用元字符

- `.` 匹配除换行符外的任意字符
- `\d` 匹配一个数字（0-9）
- `\D` 匹配一个非数字字符
- `\w` 匹配字母、数字、下划线（等价于 [A-Za-z0-9_]）
- `\W` 匹配非字母、非数字、非下划线（等价于 [^A-Za-z0-9_]）
- `\s` 匹配空白字符（空格、制表符\t、换行符\n、回车符\r、垂直制表符\v、换页符\f 等）
- `\S` 匹配非空白字符
- `^` 匹配输入的开始
- `$` 匹配输入的结束
- `*` 匹配前面的内容 0 次或多次
- `+` 匹配前面的内容 1 次或多次
- `?` 匹配前面的内容 0 次或 1 次
- `{n,m}` 匹配前面的内容至少 n 次，至多 m 次
- `[]` 字符集，如`[abc]`匹配 a、b 或 c
- `|` 或，如`a|b`匹配 a 或 b
- `()` 分组

### 4. 常用方法

- `test()`：检测字符串是否匹配正则，返回 true/false
- `exec()`：匹配字符串，返回匹配结果数组或 null
- `match()`：字符串方法，返回匹配结果数组
- `replace()`：替换匹配内容
- `split()`：分割字符串

```js
let str = "abc123def456";
let reg = /\d+/;

// test
console.log(reg.test(str));
// 返回 true（只要有匹配就返回 true）

// exec
console.log(reg.exec(str));
// 返回 ["123"]（第一个匹配项的详细信息，包括索引等）

// match
console.log(str.match(reg));
// 返回 ["123"]（和 exec 类似，返回第一个匹配项）

// replace
console.log(str.replace(reg, "***"));
// 返回 "abc***def456"（只替换第一个匹配项）

// split
console.log(str.split(reg));
// 返回 ["abc", "def456"]（用匹配到的内容分割字符串）

// ****************如果加上 g 修饰符（全局匹配），match 和 replace 的结果会不同****************
let regG = /\d+/g;
console.log(str.match(regG));
// 返回 ["123", "456"]（所有匹配项）

console.log(str.replace(regG, "***"));
// 返回 "abc***def***"（所有匹配项都被替换）
```

### 5. 示例

```js
let str = "abc123";
let reg = /\d+/;
console.log(reg.test(str)); // true
console.log(str.match(reg)); // ["123"]
console.log(str.replace(reg, "***")); // "abc***"
```

### 6. 正则表达式高级用法

#### 1. 贪婪与懒惰（惰性）匹配

- 贪婪：默认尽可能多地匹配（如 `.*`）。
- 懒惰：加 `?` 变为尽可能少地匹配（如 `.*?`）。

```js
let str = "abc123def456abc";
console.log(str.match(/\d+.*/)); // ["123def456abc"]（贪婪）
console.log(str.match(/\d+.*?/)); // ["123"]（懒惰）
```

#### 2. 分组与捕获（重点详解）

分组与捕获是正则表达式中非常重要的功能，主要用于提取、复用和限定匹配内容。

##### 1. 基本语法

- `()`：分组并捕获，匹配的内容会被保存下来，可在结果中获取。
- `(?:...)`：只分组不捕获，不会保存匹配内容。

##### 2. 捕获组的作用

- 提取字符串中的特定部分（如日期、数字、单词等）。
- 在正则内部通过反向引用（如 `\1`）复用前面分组的内容。
- 在替换时通过 `$1`、`$2` 等引用捕获内容。

##### 3. 获取捕获结果

- 通过 `match()`、`exec()` 方法返回的数组，索引 1 开始依次对应每个捕获组。
- 也可通过 `RegExp.$1`、`RegExp.$2` 获取（不推荐，易混乱）。

##### 4. 示例

```js
let str = "2023-01-12";
let reg = /(\d{4})-(\d{2})-(\d{2})/;
let result = str.match(reg);
// result[0] = "2023-01-12"（完整匹配）
// result[1] = "2023"（第1组，年份）
// result[2] = "01"（第2组，月份）
// result[3] = "12"（第3组，日期）
```

##### 5. 非捕获分组

- 语法：`(?:...)`，只分组不捕获，不会出现在结果数组中。
- 用于结构限定、分组但不需要提取内容的场景。

- 示例：

```js
let str = "foo123bar456";
// 匹配数字前面是 foo 或 bar，但只提取数字，不提取分组内容
let reg = /(?:foo|bar)(\d+)/g;
console.log(str.match(reg)); // ["foo123", "bar456"]
console.log(str.match(/(foo|bar)(\d+)/g)); // ["foo123", "bar456"]
// 但捕获组只有数字部分
let execRes = reg.exec(str);
console.log(execRes[1]); // "123"
```

- 解释：`(?:foo|bar)` 只分组不捕获，匹配 "foo" 或 "bar"，但不会出现在结果数组中。只有 `(\d+)` 捕获数字。

##### 6. 反向引用

- 在正则内部用 `\1`、`\2` 等引用前面分组内容。
- 如：`/(\w+)\1/` 匹配连续出现两次的同样单词。

##### 7. 替换中的捕获组（详细说明）

在字符串替换时，正则表达式的捕获组可以让你灵活地引用和重组匹配到的内容。

- 语法：`replace(regexp, replacement)`
- 在 replacement 字符串中，可以用 `$1`、`$2` 等引用第 1、2... 个捕获组内容。
- `$&` 表示整个匹配到的内容。
- ` $`` 表示匹配内容前的字符串， `$'` 表示匹配内容后的字符串。

**常见用法：**

```js
let str = "foo123bar456";
// 用 [] 包裹所有数字
console.log(str.replace(/(\d+)/g, "[$1]")); // "foo[123]bar[456]"

// 交换顺序
let date = "2026-01-12";
console.log(date.replace(/(\d{4})-(\d{2})-(\d{2})/, "$2/$3/$1")); // "01/12/2026"

// 用 $& 保留原内容
console.log(str.replace(/bar/, "$&-end")); // "foo123bar-end456"

// 用 $` 和 $' 获取前后内容
console.log(str.replace(/123/, "$`|$'")); // "foo|bar456"
```

**说明：**

- 捕获组让你在替换时灵活提取和重组内容，适合格式转换、内容高亮、批量处理等场景。
- 多个捕获组时，顺序按左括号出现顺序编号。
- 如果没有捕获组，$1、$2 等无效。

**注意：**

- 全局替换（g 修饰符）时，每次匹配都可用捕获组。
- 替换字符串也可以是函数，参数为每次匹配的捕获内容。

**函数替换示例：**

```js
let str = "foo123bar456";
console.log(str.replace(/(\d+)/g, (match, p1) => Number(p1) + 1)); // "foo124bar457"
```

这样可以实现更复杂的动态替换逻辑。

##### 8. 命名捕获组（ES2018+）

- 语法：`/(?<name>...)`，结果可通过 groups 属性访问。

```js
let str = "2026-01-12";
let reg = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
let result = str.match(reg);
console.log(result.groups.year); // "2026"
```

##### 9. 总结

- 分组与捕获让正则表达式不仅能判断，还能提取和复用内容，是数据提取、格式校验等场景的核心能力。

#### 3. 反向引用

- 在正则内部用 `\1`、`\2` 引用前面分组

```js
let str = "abab";
console.log(/(ab)\1/.test(str)); // true
```

#### 4. 零宽断言（先行断言/后行断言）

- 正向先行断言：`X(?=Y)`，匹配 X，后面必须跟 Y
- 负向先行断言：`X(?!Y)`，匹配 X，后面不能跟 Y
- 正向后行断言：`(?<=Y)X`，匹配 X，前面必须是 Y
- 负向后行断言：`(?<!Y)X`，匹配 X，前面不能是 Y

lookahead（先行断言）、lookbehind（后行断言）

1. 部分老浏览器不支持。
2. 它不会消耗字符，只做条件判断。

```js
let str = "foo1 bar2";
console.log(str.match(/\w+(?=\d)/g)); // ["foo", "bar"]
```

#### 5. 修饰符

- `g` 全局匹配：查找字符串中所有匹配项，不止第一个。常用于批量查找和替换。
  - 例：`str.match(/\d+/g)` 匹配所有数字。
- `i` 忽略大小写：匹配时不区分大小写。
  - 例：`/abc/i` 可匹配 "ABC"、"aBc" 等。
- `m` 多行匹配：`^` 和 `$` 匹配每一行的开头和结尾，而不是整个字符串的开头和结尾。
  - 例：`/^abc/m` 可匹配多行文本中每一行的 "abc"。
- `s` dotAll 模式：让 . 能匹配换行符（默认 . 不匹配换行）。
  - 例：`/a.*c/s` 可跨多行匹配 a 到 c 之间的所有内容。
- `u` Unicode 模式：支持 Unicode 码点的匹配，能正确处理大于 0xFFFF 的字符。
  - 例：`/\u{1F600}/u` 匹配表情符号 😀。
- `y` 粘连匹配（sticky）：只从 lastIndex 位置开始匹配，匹配不上就不再往后找，适合分段处理。

  - 例：

```js
let str = "1a2b3c";
let reg = /\d/y;
reg.lastIndex = 0;
console.log(reg.exec(str)); // ["1"]
reg.lastIndex = 1;
console.log(reg.exec(str)); // null（1 位置不是数字，粘连匹配失败）
reg.lastIndex = 2;
console.log(reg.exec(str)); // ["2"]
```

- 说明：
  - 粘连匹配只会在 lastIndex 指定的位置尝试匹配，不会自动跳过不匹配的字符。
  - 适合需要精确控制匹配位置、分段解析字符串的场景。
  - 与 g 修饰符不同，g 会自动跳到下一个可匹配位置，y 只认 lastIndex。
