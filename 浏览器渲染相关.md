#### 渲染顺序

同一组件：script → template → style
父组件 A 里面有两个子组件 B C， B 组件在 C 组件的上面
创建顺序（setup/created）：A → B → C
挂载顺序（mounted）：B → C → A
卸载顺序（unmounted）：C → B → A
父组件销毁时，会先销毁所有子组件，再销毁自己。
而对于同一层级的多个子组件（如 B、C），Vue 会按“渲染顺序的逆序”依次销毁，即先销毁后渲染的组件。

#### 从用户在地址栏输入 url 到页面展示 这中间发生了什么？

1. URL 解析：
   浏览器首先解析输入的内容，判断它是否是一个有效的 URL 或者是一个搜索查询。根据域名找到对应的 ip
2. DNS 查询：
   如果是 URL，浏览器会检查域名系统（DNS）以获取与该域名相关的 IP 地址。这一步可能涉及到缓存查找、递归 DNS 查询等。
3. 建立 TCP 连接：
   使用获得的 IP 地址，浏览器尝试通过传输控制协议（TCP）与服务器建立连接。这个过程包括三次握手（SYN, SYN-ACK, ACK）。
4. TLS 握手（如果使用 HTTPS）：
   如果网站使用 HTTPS，浏览器和服务器之间还需要进行一次安全层的握手，确保通信的安全性。这涉及证书验证、密钥交换等步骤。
5. 发送 HTTP 请求：
   一旦建立了安全连接，浏览器会发送 HTTP 请求到服务器，请求包含必要的头部信息，如请求类型（GET/POST）、路径、Cookie 等。
6. 服务器处理请求：
   服务器接收到请求后，根据请求的内容做出响应。对于静态文件，服务器直接返回文件；对于动态内容，服务器可能会运行脚本生成 HTML。
7. 接收 HTTP 响应：
   浏览器接收到服务器的响应，其中包含了状态码、头部信息和响应体。响应体通常是 HTML 文档。
8. HTML 解析：
   浏览器开始解析 HTML 文档，构建 DOM 树。在这个过程中，如果遇到外部资源（如 CSS 文件、JavaScript 文件、图片等），浏览器也会发起相应的请求下载这些资源。
9. CSSOM 构建：
   同时，浏览器还会解析 CSS 文件，构建 CSS 对象模型（CSSOM）。CSSOM 和 DOM 结合起来用于计算每个节点的样式。
10. 渲染树构建：
    将 DOM 和 CSSOM 结合起来形成渲染树，只包含需要显示在页面上的节点及其样式信息。
11. 布局 layout：
    计算每个节点在屏幕上的确切大小和位置。
12. 绘制：
    最终，浏览器将渲染树中的节点转换为屏幕上的像素，完成页面的绘制。（GPU 能够快速处理图像和视频数据的处理器）
13. JavaScript 执行：
    如果页面中有 JavaScript 脚本，它们会在适当的时机被执行，可能会修改 DOM 和 CSSOM，触发重新布局或重绘。

#### 优化 CSS 加载阻塞

**注意**：CSS 加载会阻塞页面渲染，但不会阻塞 JS 的下载，只会阻塞 JS 的执行。

1. 合并和压缩 CSS 文件：减少请求数量和文件体积，加快加载速度。
2. 使用 media 属性：为非首屏样式设置合适的 media，如 media="print" 或 media="(max-width: 600px)"，让浏览器异步加载不影响首屏渲染的 CSS。
3. 关键 CSS 内联：将首屏关键 CSS 直接写入 HTML <style> 标签，提升首屏渲染速度，其他样式异步加载。
4. 异步加载非关键 CSS：通过 JavaScript 动态插入 <link> 标签，延迟加载不影响首屏的样式。
5. 使用 preload：对重要 CSS 使用 <link rel="preload" as="style">，提前加载资源。
6. 减少 CSS 体积和复杂度：避免过多无用样式，提升解析效率。

#### 浏览器遇到 link 标签会发生什么

1. 优先判断 rel 属性，（如 stylesheet、icon、preload 等），决定要加载什么类型的资源。
2. 发起网络请求获取资源文件（rel="stylesheet"），下载对应的 css 文件（**这个过程会阻塞 DOM 渲染和 js 执行，但不会阻塞 js 下载**（因为 JS 可能会依赖样式计算结果））
3. 下载完成后，浏览器解析 CSS 内容，构建 CSSOM（CSS 对象模型）
4. 将 CSSOM 与 DOM 结合，生成渲染树，进行布局和绘制

#### link 标签的四个常见属性：crossorigin、media、rel 、as

1. crossorigin

用于控制跨域资源的请求方式（如 CSS、图片、字体等）。
常见值：
anonymous：不带凭证（cookie），只获取公开资源。
use-credentials：带凭证（cookie），可访问需要认证的资源。
影响 CORS 策略和资源能否被正确使用（如字体、图片的 canvas 操作）。

2. media

用于指定资源适用的媒体类型或条件（如屏幕宽度、打印等）。

```js
media = "screen and (max-width: 600px)"; //只在屏幕宽度小于 600px 时加载和应用样式。
```

可实现响应式和异步加载，优化首屏渲染。

3. rel

设置值为 preload ：用于提前加载资源，提高关键资源的加载优先级。
例：

<link rel="preload" as="style" href="main.css">

其余属性

```js
    stylesheet：引入外部 CSS 样式表
    icon：网页图标（favicon）
    preconnect：提前建立到第三方服务器的连接
    dns-prefetch：提前进行 DNS 解析
    prefetch：提前下载将来可能用到的资源
    modulepreload：提前加载 ES module 脚本
    manifest：引入 Web App Manifest 文件
    alternate：备用资源（如多语言、RSS）
    author：作者信息
    license：版权信息
    search：站点搜索描述
```

4. as

```js
    style：样式表
    script：JavaScript 脚本
    font：字体文件
    image：图片
    audio：音频
    video：视频
    document：文档（如 iframe）
    fetch：通用 fetch 请求
    worker：Web Worker
    track：字幕轨道
```

as 属性指定资源类型（如 style、script、font、image），帮助浏览器优化调度。
它不能单独使用，必须配合预加载相关的 rel（如 preload、prefetch、modulepreload）一起用，不能和 rel="stylesheet"、rel="icon" 等直接搭配。

**总结**：crossorigin 控制跨域，media 控制资源应用条件，ref=preload 提前加载关键资源, as 属性指定资源类型。

#### <meta> 标签

1. 字符集声明

```js
<meta charset="UTF-8">
```

指定页面编码，推荐使用 UTF-8。

2. 视口设置（移动端适配）

```js
// width=device-width：视口宽度等于设备屏幕宽度，页面宽度自适应设备。
// initial-scale=1.0：初始缩放比例为 1，页面不自动缩放。
// maximum-scale=1.0：最大缩放比例
// minimum-scale=1.0：最小缩放比例
// user-scalable=no：禁止用户手动缩放页面
// height=device-height：视口高度等于设备高度
// viewport-fit=cover：适配全面屏（刘海屏、异形屏）
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

控制页面在移动设备上的缩放和布局。

3. SEO 相关

```js
<meta name="description" content="页面描述信息">
<meta name="keywords" content="关键词1,关键词2">
```

提供页面描述和关键词，利于搜索引擎收录。

4. 作者信息

```js
<meta name="author" content="作者名">
```

5. 自动刷新/跳转

```js
// 5 秒后自动刷新或跳转到指定网址
<meta http-equiv="refresh" content="5;url=https://example.com">
```

5 秒后自动跳转到指定网址。

6. 兼容性设置

```js
<meta http-equiv="X-UA-Compatible" content="IE=edge">
```

让 IE 浏览器使用最新渲染模式。

7. 禁止搜索引擎收录

```js
<meta name="robots" content="noindex, nofollow">
```

#### 如何获取屏幕宽度

1. 获取视口（浏览器窗口）宽度：

```js
const width = window.innerWidth;
```

1. 获取整个屏幕的物理宽度（包括不可见区域）：

```js
const screenWidth = window.screen.width;
```

1. 获取文档根元素宽度（有时用于兼容性）：

```js
// document.documentElement 拿到的是html
const docWidth = document.documentElement.clientWidth;
// 获取 <body> 标签：
const body = document.body;
// 获取 <head> 标签：
const head = document.head;
```
