### 什么是动态规划的算法题？

动态规划（Dynamic Programming，简称 DP）是一种将复杂问题分解为更小子问题、并保存子问题结果以避免重复计算的算法思想。

动态规划算法题的特点：

- 问题可以分解为重叠的子问题（子问题之间有重叠）
- 存在最优子结构（整体最优解可以由子问题的最优解推导）
- 适合用递归+记忆化或迭代+状态表（数组/矩阵）来求解

常见类型：

- 最值问题（最大/最小/最优方案）：如背包问题、最长上升子序列、最短路径
- 计数问题：如不同路径数、分割方案数
- 匹配问题：如字符串编辑距离、正则匹配

经典例子：

1. 斐波那契数列
2. 背包问题（0-1 背包、完全背包）
3. 最长公共子序列/子串
4. 爬楼梯问题

解题步骤：

1. 明确状态（dp[i] 或 dp[i][j] 表示什么）
2. 状态转移方程（递推公式）
3. 初始化
4. 遍历顺序
5. 返回答案

动态规划的核心是“用空间换时间”，通过保存子问题结果，极大提升效率。

---

#### 动态规划常见例子与切入思路

#### 例题 1：斐波那契数列

题目描述：
给定一个整数 n，求斐波那契数列的第 n 项，f(n) = f(n-1) + f(n-2)，f(0)=0, f(1)=1。

思路分析：

- 状态定义：dp[i] 表示第 i 项的值。
- 状态转移方程：dp[i] = dp[i-1] + dp[i-2]
- 初始化：dp[0]=0, dp[1]=1
- 遍历顺序：从 2 到 n
- 时间复杂度：O(n)，空间复杂度：O(n)

代码实现：

```js
function fib(n) {
  if (n <= 1) return n;
  const dp = [0, 1];
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
// 示例
console.log(fib(6)); // 输出 8 (0,1,1,2,3,5,8)
```

解释：
每一项等于前两项之和。可以优化为只用两个变量存储前两项，将空间复杂度降至 O(1)。这是最经典的动态规划入门题。

#### 例题 2：爬楼梯问题

题目描述：
有 n 阶楼梯，每次可以爬 1 或 2 阶，问有多少种不同的爬法？

思路分析：

- 状态定义：dp[i] 表示到达第 i 阶的方法数。
- 状态转移方程：dp[i] = dp[i-1] + dp[i-2]（可以从第 i-1 阶爬 1 步，或从第 i-2 阶爬 2 步）
- 初始化：dp[1]=1（只有一种方法），dp[2]=2（两种方法：1+1 或 2）
- 遍历顺序：从 3 到 n
- 时间复杂度：O(n)，空间复杂度：O(n)

代码实现：

```js
function climbStairs(n) {
  if (n <= 2) return n;
  const dp = [0, 1, 2];
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
// 示例
console.log(climbStairs(5)); // 输出 8
```

解释：
本质上和斐波那契数列一样，每一阶的爬法数等于前两阶爬法数之和。这是因为要到达第 i 阶，只能从第 i-1 阶或第 i-2 阶到达。

#### 例题 3：0-1 背包问题

题目描述：
有 n 个物品，每个物品有重量和价值，背包容量为 bag，问如何选择物品使得总价值最大，每个物品只能选一次。

思路分析：

【手动推导 dp 表格过程（i+1 风格）】

以 weights = [1, 3, 4]，values = [15, 20, 30]，bag = 4 为例：

| i/前 i 个物品 | 当前考虑物品 | 物品重量 | 物品价值 |
| :-----------: | :----------: | :------: | :------: |
|       0       |      无      |    -     |    -     |
|       1       |      0       |    1     |    15    |
|       2       |      1       |    3     |    20    |
|       3       |      2       |    4     |    30    |

我们构造 dp[4][5]，行 i 表示前 i 个物品（i=0~3），列 j 表示容量（0~4）。

初始：
dp[0][j] = 0（前 0 个物品，最大价值为 0）

| j   | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| i=0 | 0   | 0   | 0   | 0   | 0   |

填 i=1（只考虑第 0 号物品）：
dp[1][j] = j >= weights[0] ? values[0] : 0

| j   | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| i=1 | 0   | 15  | 15  | 15  | 15  |

填 i=2（前 2 个物品）：
dp[2][j] = max(dp[1][j], j>=weights[1] ? dp[1]j-weights[1]]+values[1] : dp[1][j])

| j   | 0   | 1   | 2   | 3               | 4                |
| --- | --- | --- | --- | --------------- | ---------------- |
| i=2 | 0   | 15  | 15  | max(15,0+20)=20 | max(15,15+20)=35 |

详细推导：

- j=0: 不能选，继承上面 0
- j=1: 不能选，继承上面 15
- j=2: 不能选，继承上面 15
- j=3: 可选，max(15, dp[1][0]+20=20) = 20
- j=4: 可选，max(15, dp[1][1]+20=15+20=35) = 35

填 i=3（前 3 个物品）：
dp[3][j] = max(dp[2][j], j>=weights[2] ? dp[2]j-weights[2]]+values[2] : dp[2][j])

| j   | 0   | 1   | 2   | 3   | 4               |
| --- | --- | --- | --- | --- | --------------- |
| i=3 | 0   | 15  | 15  | 20  | max(35,0+30)=35 |

详细推导：

- j=0: 不能选，继承上面 0
- j=1: 不能选，继承上面 15
- j=2: 不能选，继承上面 15
- j=3: 不能选，继承上面 20
- j=4: 可选，max(35, dp[2][0]+30=0+30=30) = 35

最终 dp 表格：

| j   | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| i=0 | 0   | 0   | 0   | 0   | 0   |
| i=1 | 0   | 15  | 15  | 15  | 15  |
| i=2 | 0   | 15  | 15  | 20  | 35  |
| i=3 | 0   | 15  | 15  | 20  | 35  |

每个格子的值只和“正上方”（不选当前物品）和“左上方隔 weights[i-1] 步”（选当前物品）有关。
最终答案：dp[3][4]=35。

- 状态定义：dp[i][j] 表示前 i 个物品、容量为 j 时的最大价值。
- 状态转移方程：
  - 不选第 i 个物品：dp[i][j] = dp[i-1][j]
  - 选第 i 个物品（前提是 j >= weights[i-1]）：dp[i][j] = dp[i-1]j-weights[i-1]] + values[i-1]
  - 取最大值：dp[i][j] = max(dp[i-1][j], dp[i-1]j-weights[i-1]] + values[i-1])
- 初始化：dp[0][j]=0（前 0 个物品价值为 0）
- 遍历顺序：外层遍历物品，内层遍历容量
- 时间复杂度：O(n×bag)，空间复杂度：O(n×bag)

代码实现：

```js
/**
 * weights：物品的重量数组。例如 [1, 3, 4]，表示每个物品的重量。
 * values：物品的价值数组。例如 [15, 20, 30]，表示每个物品的价值。
 * bag：背包的总容量（最大能装多少重量）。例如 4，表示背包最多能装4单位重量。
 */

// 二维写法（i+1风格）
function knapsack(weights, values, bag) {
  const n = weights.length;
  // dp[i][j] 表示前i个物品（下标1~n），容量为j时的最大价值
  const dp = Array.from({ length: n + 1 }, () => Array(bag + 1).fill(0));
  // 初始化：dp[0][j]=0，表示前0个物品最大价值为0
  for (let i = 1; i <= n; i++) {
    for (let j = 0; j <= bag; j++) {
      // 不选第i-1号物品
      dp[i][j] = dp[i - 1][j];
      // 选第i-1号物品（前提是能装下）
      if (j >= weights[i - 1]) {
        dp[i][j] = Math.max(
          dp[i][j],
          dp[i - 1][j - weights[i - 1]] + values[i - 1]
        );
      }
    }
  }
  return dp[n][bag];
}
// 示例
console.log(knapsack([1, 3, 4], [15, 20, 30], 4)); // 输出 35

// 一维写法
function dpFn(arr1, arr2, n) {
  const dp = new Array(n + 1).fill(0);
  for (let i = 0; i < arr1.length; i++) {
    for (let j = n; j >= arr1[i]; j--) {
      dp[j] = Math.max(dp[j], dp[j - arr1[i]] + arr2[i]);
    }
  }
  return dp[n];
}
console.log(dpFn([1, 3, 4], [15, 20, 30], 4)); // 输出 35
```

解释：
以示例为例，物品重量 [1,3,4]，价值 [15,20,30]，背包容量 4。最优方案是选择物品 1(重 1 值 15)和物品 2(重 3 值 20)，总重 4，总价值 35。这是经典的二维动态规划问题，可以用滚动数组优化为一维。

#### 例题 4：最长上升子序列（LIS）

题目描述：
给定一个无序整数数组，求其中最长递增子序列的长度。（子序列不要求连续）

思路分析：

- 状态定义：dp[i] 表示以 nums[i] 结尾的最长递增子序列长度。
- 状态转移方程：对于每个 i，遍历所有 j < i，如果 nums[j] < nums[i]，则 dp[i] = max(dp[i], dp[j]+1)
- 初始化：dp[i]=1（每个元素自身就是长度为 1 的递增子序列）
- 遍历顺序：从左到右，双重循环
- 时间复杂度：O(n²)，空间复杂度：O(n)
- 可优化：使用二分查找+贪心优化至 O(n log n)

代码实现：

```js
function lengthOfLIS(nums) {
  const n = nums.length;
  if (n === 0) return 0;
  const dp = Array(n).fill(1);
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        // 可能有多个不同长度的递增子序列所以需要取两个中大的那一个
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  return Math.max(...dp);
}
// 示例
console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])); // 输出 4
```

解释：
以示例 [10,9,2,5,3,7,101,18] 为例，最长递增子序列是 [2,3,7,18] 或 [2,5,7,18] 等，长度为 4。算法思路：对于每个位置 i，向前寻找所有比它小的元素 j，从中选择 dp[j] 最大的，加 1 后更新 dp[i]。

#### 例题 5：最小路径和

题目描述：
给定一个 m x n 的网格，每个格子有一个非负整数，问从左上角到右下角，每次只能向右或向下移动，路径和最小是多少？

思路分析：

- 状态定义：dp[i][j] 表示从 (0,0) 到 (i,j) 的最小路径和。
- 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
  - **为什么是 i-1 和 j-1？** 因为我们要计算**当前位置** (i,j)，需要从**已经计算过的位置**来：
    - 从**上方**来：即上一行的同一列，坐标是 (i-1, j)，所以是 `dp[i-1][j]`
    - 从**左方**来：即同一行的左一列，坐标是 (i, j-1)，所以是 `dp[i][j-1]`
  - 从左上角走到右下角，每一步都是向右或向下，所以当前位置只能从上方或左方到达
  - 比较两条路径，选择路径和较小的那条
- 初始化：
  - dp[0][0] = grid[0][0]（起点）
  - 第一行：dp[0][j] = dp[0][j-1] + grid[0][j]（只能从左边来）
  - 第一列：dp[i][0] = dp[i-1][0] + grid[i][0]（只能从上边来）
- 遍历顺序：从上到下，从左到右（保证计算 dp[i][j] 时，dp[i-1][j] 和 dp[i][j-1] 已经算好）
- 时间复杂度：O(m×n)，空间复杂度：O(m×n)

代码实现：

```js
function minPathSum(grid) {
  const m = grid.length,
    n = grid[0].length;
  const dp = Array.from({ length: m }, () => Array(n).fill(0));
  // 初始化起点
  dp[0][0] = grid[0][0];
  // 初始化第一列
  for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
  // 初始化第一行
  for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
  // 填充其余位置
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  return dp[m - 1][n - 1];
}
// 示例
console.log(
  minPathSum([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ])
); // 输出 7 (路径: 1→3→1→1→1)
```

解释：
以示例为例，最优路径是 1→3→1→1→1，总和为 7。每个位置只能从上方或左方到达，选择路径和较小的方向。可以用滚动数组将空间复杂度优化为 O(n)。

**重点理解：dp 数组 vs grid 数组**

- **grid 数组**：原始输入，存储每个格子**本身的值**
- **dp 数组**：动态规划结果，存储**从起点(0,0)到当前位置的最小路径和**

**具体执行过程演示**（以示例为例）：

```
原始输入 grid:
[1, 3, 1]
[1, 5, 1]
[4, 2, 1]

执行步骤：

1. 初始化 dp 数组（全0）:
[0, 0, 0]
[0, 0, 0]
[0, 0, 0]

2. 设置起点 dp[0][0] = grid[0][0]:
[1, 0, 0]    // 起点的路径和就是起点值本身：1
[0, 0, 0]
[0, 0, 0]

3. 初始化第一行（只能从左边来）:
[1, 4, 5]    // dp[0][1] = dp[0][0] + grid[0][1] = 1+3 = 4
[0, 0, 0]    // dp[0][2] = dp[0][1] + grid[0][2] = 4+1 = 5
[0, 0, 0]

4. 初始化第一列（只能从上边来）:
[1, 4, 5]
[2, 0, 0]    // dp[1][0] = dp[0][0] + grid[1][0] = 1+1 = 2
[6, 0, 0]    // dp[2][0] = dp[1][0] + grid[2][0] = 2+4 = 6

5. 填充 dp[1][1]（可以从上或左来，选小的）:
[1, 4, 5]
[2, 7, 0]    // min(dp[0][1]=4, dp[1][0]=2) + grid[1][1] = min(4,2)+5 = 7
[6, 0, 0]

6. 填充 dp[1][2]:
[1, 4, 5]
[2, 7, 6]    // min(dp[0][2]=5, dp[1][1]=7) + grid[1][2] = min(5,7)+1 = 6
[6, 0, 0]

7. 填充 dp[2][1]:
[1, 4, 5]
[2, 7, 6]
[6, 8, 0]    // min(dp[1][1]=7, dp[2][0]=6) + grid[2][1] = min(7,6)+2 = 8

8. 填充 dp[2][2]（最终答案）:
[1, 4, 5]
[2, 7, 6]
[6, 8, 7]    // min(dp[1][2]=6, dp[2][1]=8) + grid[2][2] = min(6,8)+1 = 7

最终 dp 数组的含义：
dp[i][j] = 从(0,0)到(i,j)的最小路径和

dp[0][0]=1  表示 (0,0)到(0,0) 的路径和是 1
dp[0][1]=4  表示 (0,0)到(0,1) 的最小路径和是 4 (路径: 1→3)
dp[1][1]=7  表示 (0,0)到(1,1) 的最小路径和是 7 (路径: 1→3→3→5 或 1→1→5)
dp[2][2]=7  表示 (0,0)到(2,2) 的最小路径和是 7 (路径: 1→3→1→1→1)

答案：return dp[2][2] = 7
```

**关键点**：

- grid[i][j] 只是**当前格子的值**（比如 grid[1][1]=5）
- dp[i][j] 是**累计路径和**（比如 dp[1][1]=7，表示从起点走到这里的最小总和）
- dp 数组是通过不断累加 grid 的值计算出来的

---

**常见思维误区纠正：为什么不是 [i+1][j] 和 [i][j+1]？**

**你的直觉思维（❌ 错误但很自然）**：

```
站在当前位置 (i,j)，看"下一步"往哪走
- 往下走：[i+1][j]
- 往右走：[i][j+1]
比较两条路，选小的

这是"向前看"的思维：从当前推未来
```

**动态规划思维（✅ 正确）**：

```
站在目标位置 (i,j)，看"上一步"从哪来
- 从上方来：[i-1][j]
- 从左方来：[i][j-1]
比较两条路，选小的

这是"向后看"的思维：从已知推未知
```

**为什么"向前看"行不通？**

1. **信息不完整问题**：

   ```
   假设你在 (0,0)，想知道往下 (1,0) 还是往右 (0,1)？

   向前看的困境：
   - (1,0) 的最优路径还没算出来，你不知道走这条路最终会怎样
   - (0,1) 的最优路径也还没算，你也不知道
   - 你无法做出正确选择，因为未来还是未知的

   这就像走迷宫时，每个路口都不知道哪条路通往出口
   ```

2. **计算顺序混乱**：

   ```
   如果用 [i+1][j] 和 [i][j+1]：
   - 要计算 dp[0][0]，需要先知道 dp[1][0] 和 dp[0][1]
   - 要计算 dp[1][0]，需要先知道 dp[2][0] 和 dp[1][1]
   - 要计算 dp[2][0]，需要先知道 dp[3][0]...（越界了！）

   形成死锁：每个位置都依赖后面的位置，谁都算不出来
   ```

3. **实际例子**：

   ```
   grid:
   [1, 3, 1]
   [1, 5, 1]
   [4, 2, 1]

   站在 (0,0)=1，用"向前看"：
   - 往下走到 (1,0)=1，但从 (1,0) 再怎么走最优？不知道！
   - 往右走到 (0,1)=3，但从 (0,1) 再怎么走最优？不知道！
   - 无法比较，因为后续路径未知

   结论：向前看需要递归到终点，效率极低或根本算不出来
   ```

**为什么"向后看"可行？**

1. **已知信息充足**：

   ```
   假设你要计算 (1,1) 的最优路径：

   向后看的优势：
   - dp[0][1]=4 已经算好了（从起点到这里的最优路径和）
   - dp[1][0]=2 也已经算好了
   - 只需要选较小的：min(4,2)=2，再加上当前格子 grid[1][1]=5
   - dp[1][1] = 2+5 = 7

   这就像爬楼梯，每一阶都基于前面已经爬过的阶数
   ```

2. **计算顺序清晰**：

   ```
   按照 从左到右、从上到下 的顺序：

   [✓, ✓, ✓]    第一行算完
   [✓, ?, ?]    第二行正在算 dp[1][1]，它依赖的 dp[0][1] 和 dp[1][0] 都已经算好
   [?, ?, ?]

   每个位置只依赖左边和上边（已经算过的），永远不会出现死锁
   ```

**如何纠正思维方式？**

**训练方法 1：倒着想问题**

```
不要想："我从起点出发，该往哪走？"（向前看）
而要想："我要到这个点，可能从哪来？"（向后看）

例如：
- 错误思考：在 (0,0)，我往下还是往右？（未来未知）
- 正确思考：在 (1,1)，我可能从 (0,1) 或 (1,0) 来（过去已知）
```

**训练方法 2：从终点反推**

```
从终点 (2,2) 开始想：
- 要到 (2,2)，我可能从哪来？
  → 从 (1,2) 或 (2,1)

- 要到 (1,2)，我可能从哪来？
  → 从 (0,2) 或 (1,1)

- 要到 (1,1)，我可能从哪来？
  → 从 (0,1) 或 (1,0)

这样一直反推到起点 (0,0)，就是动态规划的顺序
```

**训练方法 3：记住动态规划的本质**

```
动态规划 = 用"过去"（已知）推导"现在"（未知）

就像数学归纳法：
- 已知 f(1), f(2)... f(n-1)
- 推导 f(n)

不是：
- 已知 f(n)
- 去猜测 f(n+1), f(n+2)...（这是模拟/贪心，不是DP）
```

**对比总结**：

| 维度     | 向前看 [i+1][j] ❌     | 向后看 [i-1][j] ✅   |
| -------- | ---------------------- | -------------------- |
| 思维方式 | 从当前推未来           | 从过去推当前         |
| 信息状态 | 未来未知               | 过去已知             |
| 计算顺序 | 死锁（需要未计算的值） | 流畅（所需值已计算） |
| 适用场景 | 模拟、搜索             | 动态规划             |
| 例子     | "我往哪走？"           | "我从哪来？"         |

**记忆口诀**：

> **动态规划看"来路"，不看"去路"**  
> **用"已知"算"未知"，不用"未知"猜"未知"**  
> **过去确定，未来待定**

**实战检验**：
下次遇到类似问题，问自己：

1. 我现在要算的这个位置，依赖什么信息？
2. 这些信息现在有没有？
3. 如果没有，是不是顺序错了？

如果答案都是"有"，那就对了！

---

#### 例题 6：使字符串平衡的最少删除次数

题目描述：
给你一个字符串 s，仅包含字符 'a' 和 'b'。你可以删除 s 中任意数量的字符，使得 s 平衡。
我们称 s 平衡，当且仅当不存在下标对 (i, j) 满足 i < j 且 s[i] = 'b' 同时 s[j] = 'a'。
请你返回使 s 平衡的最少删除次数。

示例 1：
输入：s = "aabbababb"
输出：2
解释：删除下标 4 和 6 的两个 'a'（"aabbababb" -> "aabbbbbb"），满足所有 'a' 都在所有 'b' 之前。

示例 2：
输入：s = "bbaaaaabb"
输出：2
解释：唯一的最优解是删除最后两个字符。

思路分析：

- 题目要求不存在 i < j 且 s[i]='b' 且 s[j]='a'，即 'b' 不能出现在 'a' 之前。
- 最终字符串形式：所有 'a' 都在所有 'b' 之前（如 "aaa...bbb..."）。
- **动态规划思路**（空间优化版本）：
  - 设 dp[i] 表示处理前 i 个字符的最少删除次数。
  - 状态转移方程：
    - 若 s[i]='b'：dp[i] = dp[i-1]（保留这个 'b'）
    - 若 s[i]='a'：dp[i] = min(dp[i-1] + 1, bCount)
      - dp[i-1] + 1：删除这个 'a'
      - bCount：删除前面所有的 'b'（保留这个 'a'）
  - 空间优化：用一个变量 res 代替 dp 数组，用 bCount 记录前面的 'b' 数量。
- 时间复杂度：O(n)
  - 只有一个 for 循环遍历字符串，每个字符处理一次
  - 循环内部都是 O(1) 的常数时间操作（比较、赋值、Math.min）
- 空间复杂度：O(1)
  - 只使用了 res 和 bCount 两个变量
  - 不管输入字符串多长，额外空间使用量固定
  - 相比完整 dp 数组的 O(n) 空间，已优化为常数空间

代码实现（动态规划-空间优化）：

```js
function minimumDeletions(s) {
  let res = 0; // dp[i]，当前最少删除次数
  let bCount = 0; // 前面保留的 b 的数量
  for (let c of s) {
    if (c === "b") {
      bCount++; // 保留这个 'b'
    } else {
      // 遇到 'a'，状态转移：要么删掉这个 'a'（res+1），要么删掉前面所有的 'b'（bCount）
      res = Math.min(res + 1, bCount);
    }
  }
  return res;
}
// 示例
console.log(minimumDeletions("aabbababb")); // 输出 2
```

解释：

以示例 "aabbababb" 为例，逐步分析：

- 遇到 'a'：res=0, bCount=0
- 遇到 'a'：res=0, bCount=0
- 遇到 'b'：bCount=1
- 遇到 'b'：bCount=2
- 遇到 'a'：res = min(0+1, 2) = 1, bCount=2
- 遇到 'b'：bCount=3
- 遇到 'a'：res = min(1+1, 3) = 2, bCount=3
- 遇到 'b'：bCount=4
- 遇到 'b'：bCount=5

最终 res=2，即删除下标 4 和 6 的两个 'a'，得到 "aabbbbbb"，满足所有 'a' 在所有 'b' 之前。

这种题的切入点：

- 明确最终目标（所有 'a' 必须在所有 'b' 之后）
- 动态规划/贪心建模，维护前缀 a 的数量和最优删除次数

---

切入动态规划问题的常用思路：

#### 步骤 1：明确"状态"——用什么变量描述子问题？

**核心思想**：找到能够表示子问题的变量，这个变量通常是一个数组（一维或二维）。

**常见状态定义**：

- **dp[i]**：表示"处理到第 i 个元素时"的某个结果
  - 例：dp[i] = 到达第 i 阶楼梯的方法数
  - 例：dp[i] = 以第 i 个数结尾的最长递增子序列长度
- **dp[i][j]**：表示"处理到第 i 个元素，且满足某条件 j 时"的结果
  - 例：dp[i][j] = 前 i 个物品，容量为 j 时的最大价值
  - 例：dp[i][j] = 从 (0,0) 到 (i,j) 的最小路径和

**如何确定状态**：

1. 看问题求什么：最值？方案数？是否可行？
2. 尝试用递归思考：f(n) 和 f(n-1)、f(n-2) 有什么关系？
3. 确定状态需要几个维度：一个参数够用吗？需要额外条件吗？

**示例**（爬楼梯）：

- 问题：爬到第 n 阶有多少种方法？
- 状态：dp[i] 表示爬到第 i 阶的方法数
- 为什么这样定义：因为爬到第 i 阶只依赖于前面的阶数

---

#### 步骤 2：写出"状态转移方程"——当前状态如何由子状态推导？

**核心思想**：找出当前状态和之前状态的数学关系，这是动态规划的灵魂。

**常见转移类型**：

- **加法原理**（方案数累加）：
  - dp[i] = dp[i-1] + dp[i-2]
  - 当前方案数 = 所有子方案数之和
- **取最值**（最优子结构）：
  - dp[i] = max(dp[i-1], dp[i-2] + nums[i])
  - 当前最优解 = 从多个子问题中选最优
- **条件转移**（根据情况分类讨论）：
  - if (条件) dp[i] = ... else dp[i] = ...

**推导技巧**：

1. 列举当前状态的**所有可能来源**
2. 对于每种来源，写出对应的转移
3. 根据问题类型（最值/计数）合并这些转移

**示例**（0-1 背包）：

- 状态：dp[i][j] = 前 i 个物品，容量 j 的最大价值
- 第 i 个物品有两种选择：
  - **不放**：dp[i][j] = dp[i-1][j]
  - **放入**（前提 j >= weight[i]）：dp[i][j] = dp[i-1]j-weight[i]] + value[i]
- 转移方程：dp[i][j] = max(不放, 放入) = max(dp[i-1][j], dp[i-1]j-weight[i]] + value[i])

---

#### 步骤 3：明确"初始值"——最小子问题的解是什么？

**核心思想**：确定递推的起点，通常是最简单、最基础的情况。

**常见初始化**：

- **边界情况**：dp[0]、dp[1] 等基础情况
  - 例：dp[0] = 0, dp[1] = 1（斐波那契）
  - 例：dp[0][0] = grid[0][0]（路径和的起点）
- **第一行/第一列**：二维数组的边界
  - 例：dp[i][0] = 只有一种路径（沿第一列走）
  - 例：dp[0][j] = 只有一种路径（沿第一行走）
- **默认值**：有些问题需要特殊默认值
  - 例：求最小值时，初始化为 Infinity
  - 例：求最大值时，初始化为 -Infinity

**示例**（爬楼梯）：

- dp[1] = 1（到第 1 阶只有 1 种方法：走 1 步）
- dp[2] = 2（到第 2 阶有 2 种方法：走 1+1 或走 2）
- 有了这两个初始值，就能递推出后续所有值

---

#### 步骤 4：明确"遍历顺序"——一维/二维、正序/倒序？

**核心思想**：确保计算当前状态时，所依赖的子状态已经计算完毕。

**遍历原则**：

- **依赖关系**：先计算被依赖的，后计算依赖者
- **一维数组**：
  - 正序：dp[i] 依赖 dp[i-1]、dp[i-2] 等前面的值
  - 倒序：dp[i] 依赖 dp[i+1]、dp[i+2] 等后面的值（少见）
- **二维数组**：
  - 通常：外层遍历行 i，内层遍历列 j
  - 特殊：背包问题有时需要倒序遍历容量

**示例**（最长递增子序列）：

```js
for (let i = 0; i < n; i++) {
  // 外层：当前位置
  for (let j = 0; j < i; j++) {
    // 内层：前面所有位置
    if (nums[j] < nums[i]) {
      dp[i] = Math.max(dp[i], dp[j] + 1);
    }
  }
}
```

- 为什么 j < i：因为 dp[i] 依赖前面所有 dp[j]
- 如果 j 从 i 开始，会用到还没计算的值（错误）

---

#### 步骤 5：返回"最终答案"——通常是 dp[n] 或 dp[n][m]

**核心思想**：根据状态定义，找到目标答案的位置。

**常见返回值**：

- **单个状态**：
  - return dp[n]（问题规模为 n 的最终结果）
  - return dp[m-1][n-1]（二维数组的右下角）
- **数组最值**：
  - return Math.max(...dp)（所有状态中的最大值）
  - return Math.min(...dp)（所有状态中的最小值）
- **累加结果**：
  - return dp.reduce((a,b) => a+b)（所有状态之和）

**示例对比**：

- 爬楼梯：return dp[n]（恰好 n 阶的方法数）
- 最长递增子序列：return Math.max(...dp)（以任意位置结尾的最大值）
- 背包问题：return dp[n][bag]（所有物品、满容量的最大价值）

---

#### 综合示例：从零推导爬楼梯问题

**问题**：n 阶楼梯，每次爬 1 或 2 阶，有多少种爬法？

**步骤 1 - 明确状态**：

- dp[i] = 到达第 i 阶的方法数

**步骤 2 - 状态转移**：

- 到达第 i 阶，可能从哪来？
  - 从第 i-1 阶爬 1 步：有 dp[i-1] 种方法
  - 从第 i-2 阶爬 2 步：有 dp[i-2] 种方法
- 转移方程：dp[i] = dp[i-1] + dp[i-2]

**步骤 3 - 初始值**：

- dp[1] = 1（只能走 1 步）
- dp[2] = 2（可以走 1+1 或 2）

**步骤 4 - 遍历顺序**：

- 正序：i 从 3 到 n（因为 dp[i] 依赖前面的值）

**步骤 5 - 返回答案**：

- return dp[n]

```js
function climbStairs(n) {
  if (n <= 2) return n;
  const dp = [0, 1, 2]; // 初始值
  for (let i = 3; i <= n; i++) {
    // 遍历顺序
    dp[i] = dp[i - 1] + dp[i - 2]; // 状态转移
  }
  return dp[n]; // 返回答案
}
```

---

#### 什么时候用动态规划？

遇到以下类型问题，优先考虑动态规划：

1. **最值问题**：求最大/最小/最优方案
   - 关键词：最长、最短、最大、最小、最优
   - 例：最长子序列、最小路径、最大价值
2. **方案数问题**：求有多少种方法/方案
   - 关键词：多少种、方案数、可能性
   - 例：爬楼梯方案数、路径数、组合数
3. **计数问题**：求满足条件的数量
   - 关键词：数量、个数、次数
   - 例：删除次数、分割次数、匹配数
4. **匹配问题**：求是否可行、能否达成
   - 关键词：是否、能否、可以
   - 例：背包能否装满、字符串能否匹配

**判断技巧**：

- 问题能否分解为**重叠的子问题**？（子问题会被重复计算）
- 是否存在**最优子结构**？（最优解包含子问题的最优解）
- 暴力递归是否会超时？（动态规划用空间换时间）

如果以上都满足，用动态规划就对了！

#### 例题 7：零钱兑换（最少硬币数）

题目描述：
给定不同面额的硬币 coins 和一个总金额 amount，求凑成该金额所需的最少硬币数。如果无解返回 -1。

思路分析：

- 状态定义：dp[i] 表示凑成金额 i 所需的最少硬币数。
- 状态转移：dp[i] = min(dp[i], dp[i-coin] + 1)（遍历所有 coin）
- 初始化：dp[0]=0，其余为 Infinity。
- 遍历顺序：从小到大。

代码实现：

```js
function coinChange(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount];
}
// 示例
console.log(coinChange([1, 2, 5], 11)); // 输出 3 (11=5+5+1)
```

---

#### 例题 8：分割等和子集

题目描述：
给定一个只包含正整数的数组，判断能否将其分割为两个和相等的子集。

思路分析：

- 转化为 0-1 背包问题，目标容量为 sum/2。
- 状态定义：dp[i] 表示容量为 i 时能否恰好装满。
- 状态转移：dp[i] = dp[i] || dp[i-num]
- 初始化：dp[0]=true。

代码实现：

```js
function canPartition(nums) {
  const sum = nums.reduce((a, b) => a + b, 0);
  if (sum % 2 !== 0) return false;
  const target = sum / 2;
  const dp = Array(target + 1).fill(false);
  dp[0] = true;
  for (let num of nums) {
    for (let i = target; i >= num; i--) {
      dp[i] = dp[i] || dp[i - num];
    }
  }
  return dp[target];
}
// 示例
console.log(canPartition([1, 5, 11, 5])); // 输出 true
```

---

#### 例题 9：编辑距离（Levenshtein Distance）

题目描述：
给定两个单词 word1 和 word2，返回将 word1 转换成 word2 所需的最少操作数（插入、删除、替换）。

思路分析：

- 状态定义：dp[i][j] 表示 word1 前 i 个字符和 word2 前 j 个字符的最小编辑距离。
- 状态转移：
  - 若 word1[i-1] == word2[j-1]，dp[i][j] = dp[i-1][j-1]
  - 否则 dp[i][j] = 1 + min(插入, 删除, 替换)
- 初始化：dp[0][j]=j, dp[i][0]=i

代码实现：

```js
function minDistance(word1, word2) {
  const m = word1.length,
    n = word2.length;
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
      }
    }
  }
  return dp[m][n];
}
// 示例
console.log(minDistance("horse", "ros")); // 输出 3
```

---

#### 编辑距离核心逻辑详解（大白话版）

**核心代码：**

```js
if (word1[i - 1] === word2[j - 1]) {
  dp[i][j] = dp[i - 1][j - 1];
} else {
  dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
}
```

**关键理解：**

- `dp[i][j]` 的含义：把 word1 的**前 i 个字符**变成 word2 的**前 j 个字符**，最少需要几步
- `word1[i-1]` 和 `word2[j-1]`：当前正在比较的两个字符（数组下标从 0 开始，所以是 i-1 和 j-1）

---

**情况 1：当前字符相等 —— 白送！不用操作！**

```js
if (word1[i - 1] === word2[j - 1]) {
  dp[i][j] = dp[i - 1][j - 1]; // 直接继承左上角的值
}
```

**大白话解释：**

```
假设要把 "abc" 变成 "adc"：

当计算 dp[3][3] 时（把 "abc" 变成 "adc"）：
- word1[2] = 'c'，word2[2] = 'c'，两个字符一样！
- 这意味着：最后一个字符已经匹配了，不需要任何操作
- 所以只需要看前面的：把 "ab" 变成 "ad" 需要几步？
- dp[2][2] = 1（前面需要 1 步）
- 那么 dp[3][3] = dp[2][2] = 1（还是 1 步，最后这个 'c' 白送）

记住：字符相等 = 白送 = 直接继承左上角，不管周围是几！
```

**为什么不能取周围的最小值？**

```
假设周围的值是：
        5
    2   ??
    3

如果取最小值 2，逻辑就乱了！
正确做法：dp[i][j] = 5

为什么？
因为左上角的 5 表示：
"前面的子串需要 5 步才能匹配，现在最后一个字符白送了，所以还是 5 步"

这不是在"选择"，而是在"继承"！
```

---

**情况 2：当前字符不等 —— 必须操作！三选一！**

```js
else {
    dp[i][j] = 1 + Math.min(
        dp[i - 1][j],      // 上方：删除
        dp[i][j - 1],      // 左方：插入
        dp[i - 1][j - 1]   // 左上：替换
    );
}
```

**大白话解释（三种操作）：**

**操作 1：删除 —— `dp[i-1][j]`（正上方）**

```
意思：先把 word1 的前 i-1 个字符变成 word2 的前 j 个字符，
     然后删掉 word1 的第 i 个字符

例子：把 "horse" 变成 "ros"
假设现在要计算 dp[5][3]（把 "horse" 变成 "ros"）
- 先把 "hors" 变成 "ros"（这需要 dp[4][3] 步）
- 然后删掉 "horse" 的最后一个 'e'（+1 步）
- 总共：dp[4][3] + 1 步

图示：
        ros
    hors [已完成]
    horse ← 删掉这个 e
```

**操作 2：插入 —— `dp[i][j-1]`（正左方）**

```
意思：先把 word1 的前 i 个字符变成 word2 的前 j-1 个字符，
     然后插入 word2 的第 j 个字符

例子：把 "horse" 变成 "ros"
假设现在要计算 dp[5][3]（把 "horse" 变成 "ros"）
- 先把 "horse" 变成 "ro"（这需要 dp[5][2] 步）
- 然后插入一个 's'（+1 步）
- 总共：dp[5][2] + 1 步

图示：
        ro [已完成] + 插入s → ros
    horse
```

**操作 3：替换 —— `dp[i-1][j-1]`（左上方）**

```
意思：先把 word1 的前 i-1 个字符变成 word2 的前 j-1 个字符，
     然后把 word1[i] 替换成 word2[j]

例子：把 "horse" 变成 "ros"
假设现在要计算 dp[5][3]（把 "horse" 变成 "ros"）
- 先把 "hors" 变成 "ro"（这需要 dp[4][2] 步）
- 然后把 'e' 替换成 's'（+1 步）
- 总共：dp[4][2] + 1 步

图示：
        ro [已完成]
    hors
       e → 替换成 s
```

**三选一：取最小的！**

```
比较三种操作：
- 删除：dp[i-1][j] + 1
- 插入：dp[i][j-1] + 1
- 替换：dp[i-1][j-1] + 1

选最少的那个！
```

---

**完整例子演示：把 "ab" 变成 "ac"**

```
构造 dp 表格：
        ""  a   c
    ""  0   1   2
    a   1   ?   ?
    b   2   ?   ?

计算 dp[1][1]（把 "a" 变成 "a"）：
- word1[0]='a'，word2[0]='a'，相等！
- dp[1][1] = dp[0][0] = 0（白送）

计算 dp[1][2]（把 "a" 变成 "ac"）：
- word1[0]='a'，word2[1]='c'，不等
- 删除：dp[0][2] + 1 = 2 + 1 = 3
- 插入：dp[1][1] + 1 = 0 + 1 = 1 ✓ 最优
- 替换：dp[0][1] + 1 = 1 + 1 = 2
- dp[1][2] = 1

计算 dp[2][1]（把 "ab" 变成 "a"）：
- word1[1]='b'，word2[0]='a'，不等
- 删除：dp[1][1] + 1 = 0 + 1 = 1 ✓ 最优
- 插入：dp[2][0] + 1 = 2 + 1 = 3
- 替换：dp[1][0] + 1 = 1 + 1 = 2
- dp[2][1] = 1

计算 dp[2][2]（把 "ab" 变成 "ac"）：
- word1[1]='b'，word2[1]='c'，不等
- 删除：dp[1][2] + 1 = 1 + 1 = 2
- 插入：dp[2][1] + 1 = 1 + 1 = 2
- 替换：dp[1][1] + 1 = 0 + 1 = 1 ✓ 最优
- dp[2][2] = 1

最终表格：
        ""  a   c
    ""  0   1   2
    a   1   0   1
    b   2   1   1

答案：dp[2][2] = 1（把 'b' 替换成 'c'）
```

---

**记忆口诀：**

```
字符相等：
  dp[i][j] = dp[i-1][j-1]
  （白送！直接继承左上角，闭眼拿！）

字符不等：
  dp[i][j] = 1 + min(上, 左, 左上)
  （三选一：删除、插入、替换，取最优！）

永远记住：
  上方 = 删除 word1[i]
  左方 = 插入 word2[j]
  左上 = 替换 word1[i] 为 word2[j]
```

---

#### 例题 10：最大子数组和（连续子数组最大和）

题目描述：
给定一个整数数组，找到一个具有最大和的连续子数组，返回其最大和。

思路分析：

- 状态定义：dp[i] 表示以 nums[i] 结尾的最大连续子数组和。
- 状态转移：dp[i] = Math.max(nums[i], dp[i-1] + nums[i])
- 初始化：dp[0]=nums[0]

代码实现：

```js
function maxSubArray(nums) {
  let maxSum = nums[0],
    curr = nums[0];
  for (let i = 1; i < nums.length; i++) {
    curr = Math.max(nums[i], curr + nums[i]);
    maxSum = Math.max(maxSum, curr);
  }
  return maxSum;
}
// 示例
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4])); // 输出 6
```

---

#### 例题 11：不同路径（机器人走路）

题目描述：
一个 m x n 的网格，机器人只能向右或向下走，问从左上角到右下角有多少条不同的路径？

思路分析：

- 状态定义：dp[i][j] 表示到达 (i,j) 的路径数。
- 状态转移：dp[i][j] = dp[i-1][j] + dp[i][j-1]
- 初始化：第一行和第一列都为 1。

代码实现：

```js
function uniquePaths(m, n) {
  const dp = Array.from({ length: m }, () => Array(n).fill(1));
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
}
// 示例
console.log(uniquePaths(3, 7)); // 输出 28
```

#### 例题 12： 最小硬币兑换（零钱兑换）

题目：给定硬币面额和总金额，最少用多少枚硬币凑出总额？

思路：

金额 i 的最优解 = min(所有 i-coin 的最优解) + 1
也就是“最后一枚硬币选哪个面额”，枚举所有可能
状态定义：dp[i]表示凑出金额 i 的最少硬币数
转移方程：dp[i] = min(dp[i-coin] + 1)
初始值：dp[0]=0，其余为 Infinity

```js
function coinChange(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(coinChange([1, 2, 5], 11)); // 输出 3，解释：11=5+5+1
console.log(coinChange([2], 3)); // 输出 -1，解释：无法凑出3
console.log(coinChange([1], 0)); // 输出 0，解释：不用硬币也能凑出0
console.log(coinChange([1], 2)); // 输出 2，解释：2=1+1
console.log(coinChange([2, 5, 10], 6)); // 输出 3，解释：6=2+2+2
```
