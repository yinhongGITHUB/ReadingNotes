#### 实现深拷贝

```js
function deepClone<T extends object>(target: T, map = new WeakMap()): T {
  if (typeof target !== 'object' || target === null) return target;
  if (map.has(target)) return map.get(target);

  const clone: any = Array.isArray(target) ? [] : {};
  map.set(target, clone);

  for (const key in target) {
    // if (Object.prototype.hasOwnProperty.call(target, key)) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone((target as any)[key], map);
    }
  }
  return clone;
}
```

#### JSON.parse(JSON.stringify(obj)) 进行深拷贝有以下主要缺点

1. 无法拷贝函数、Symbol、undefined
   对象中的函数、Symbol、undefined 属性会被忽略或丢失。

2. 无法拷贝特殊对象类型
   如 Date、RegExp、Map、Set、Error、BigInt、NaN、Infinity 等，序列化后会变成普通对象或丢失信息。

3. 循环引用会报错
   如果对象内部有循环引用（自己引用自己），会抛出 TypeError。

4. 原型链丢失
   拷贝后的对象原型链会变成 Object，原有的类实例信息丢失。

5. 只能处理可序列化的数据
   如 DOM 节点、函数、特殊对象等都无法正确拷贝。

#### 实现 Promise

```js
const PROMISE_STATE = {
  PENDING: "pending",
  FULFILLED: "fulfilled",
  REJECTED: "rejected",
};

class MyPromise {
  constructor(executor) {
    if (typeof executor !== "function") throw new TypeError("执行器必须是函数");
    this.state = PROMISE_STATE.PENDING;
    this.value = undefined;
    this.handlers = [];

    const resolve = this.#settle.bind(this, PROMISE_STATE.FULFILLED);
    const reject = this.#settle.bind(this, PROMISE_STATE.REJECTED);

    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  #settle(state, result) {
    if (this.state !== PROMISE_STATE.PENDING) return;
    if (state === PROMISE_STATE.FULFILLED && result === this)
      throw new TypeError("Promise 不能解析为自身");

    if (state === PROMISE_STATE.FULFILLED && this.#isThenable(result)) {
      try {
        result.then(
          (val) => this.#settle(PROMISE_STATE.FULFILLED, val),
          (err) => this.#settle(PROMISE_STATE.REJECTED, err)
        );
      } catch (err) {
        this.#settle(PROMISE_STATE.REJECTED, err);
      }
      return;
    }

    this.state = state;
    this.value = result;
    this.#flushHandlers();
  }

  #flushHandlers() {
    queueMicrotask(() => {
      while (this.handlers.length) {
        const { onFulfilled, onRejected, resolve, reject } =
          this.handlers.shift();
        try {
          if (this.state === PROMISE_STATE.FULFILLED) {
            resolve(
              typeof onFulfilled === "function"
                ? onFulfilled(this.value)
                : this.value
            );
          } else {
            if (typeof onRejected === "function") {
              resolve(onRejected(this.value));
            } else {
              reject(this.value);
            }
          }
        } catch (err) {
          reject(err);
        }
      }
    });
  }

  #isThenable(value) {
    return (
      (typeof value === "object" || typeof value === "function") &&
      value !== null &&
      typeof value.then === "function"
    );
  }

  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      this.handlers.push({ onFulfilled, onRejected, resolve, reject });
      if (this.state !== PROMISE_STATE.PENDING) this.#flushHandlers();
    });
  }

  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onSettled) {
    return this.then(
      (value) => MyPromise.resolve(onSettled?.()).then(() => value),
      (reason) =>
        MyPromise.resolve(onSettled?.()).then(() => {
          throw reason;
        })
    );
  }

  static resolve(value) {
    return value instanceof MyPromise
      ? value
      : new MyPromise((resolve) => resolve(value));
  }

  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }
}
```

实现了最小可用的 Promise 内核：状态管理、链式调用、错误冒泡、finally 与静态 resolve/reject，使用 microtask 模拟原生异步执行队列。

#### 实现 Promise.all

```js
function promiseAll(iterable) {
  if (!iterable || typeof iterable[Symbol.iterator] !== "function")
    throw new TypeError("参数必须是可迭代对象");

  return new Promise((resolve, reject) => {
    const results = [];
    let settledCount = 0;
    let total = 0;

    for (const item of iterable) {
      const index = total;
      total += 1;
      Promise.resolve(item)
        .then((value) => {
          results[index] = value;
          settledCount += 1;
          if (settledCount === total) resolve(results);
        })
        .catch(reject);
    }

    if (total === 0) resolve(results);
  });
}
```

遍历输入并按顺序填充结果，同时统计完成数量；当任意成员拒绝时立即拒绝外层 Promise，与原生 Promise.all 行为一致。

#### 实现 call

```js
Function.prototype.myCall = function (context, ...args) {
  if (typeof this !== "function") throw new TypeError("myCall 必须由函数调用");
  const receiver =
    context === null || context === undefined ? globalThis : Object(context);
  const key = Symbol("fn");
  receiver[key] = this; // receiver[key]就是调用的那个函数 例如show
  const result = receiver[key](...args);
  delete receiver[key];
  return result;
};
function show(a, b) {
  console.log(this.x, a, b);
}
show.call({ x: "张三" }, 1, 2);
```

临时在目标对象上挂载函数避免属性名冲突，利用 Symbol 隔离，保证 null/undefined 时自动指向全局对象。

#### 实现防抖（debounce）与节流（throttle）

**防抖（debounce）**：高频事件触发时，只有最后一次触发后经过 n 毫秒才会执行回调。常用于输入框实时搜索、窗口 resize 等。

```js
function debounce(fn, delay = 300) {
  let timer = null;
  return function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

**节流（throttle）**：高频事件触发时，保证 n 毫秒内只会执行一次回调。常用于滚动、拖拽、页面 resize 等场景。

```js
function throttle(fn, delay = 300) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime > delay) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}
```

// 用法示例
window.addEventListener('scroll', throttle(() => {
console.log('滚动事件触发');
}, 500));

// 防抖和节流的区别：
// 防抖关注“最后一次”触发，节流关注“每隔一段时间”触发一次。

#### 给定 n 个数中随机取出 m 个数，要求等概率

```js
function sampleSubsetEqualProbability(arr, m) {
  if (!Array.isArray(arr)) throw new TypeError("参数必须是数组");
  const n = arr.length;
  if (m < 0 || m > n) throw new RangeError("m 需要满足 0 ≤ m ≤ 数组长度");

  const pool = arr.slice();
  for (let i = 0; i < m; i++) {
    const j = i + Math.floor(Math.random() * (n - i));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  return pool.slice(0, m);
}
```

使用局部 Fisher-Yates 洗牌，仅对前 m 个位置执行置换操作，能保证每个组合出现概率一致。复制原数组后再操作，避免修改输入。时间复杂度为 O(n)，空间复杂度为 O(n)。
当参数无效时会抛出中文错误提示，便于调用方快速定位问题。
