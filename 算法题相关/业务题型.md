#### 实现深拷贝

```js
function deepClone<T extends object>(target: T, map = new WeakMap()): T {
  if (typeof target !== 'object' || target === null) return target;
  if (map.has(target)) return map.get(target);

  const clone: any = Array.isArray(target) ? [] : {};
  map.set(target, clone);

  for (const key in target) {
    // if (Object.prototype.hasOwnProperty.call(target, key)) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone((target as any)[key], map);
    }
  }
  return clone;
}
```

#### JSON.parse(JSON.stringify(obj)) 进行深拷贝有以下主要缺点

1. 无法拷贝函数、Symbol、undefined
   对象中的函数、Symbol、undefined 属性会被忽略或丢失。

2. 无法拷贝特殊对象类型
   如 Date、RegExp、Map、Set、Error、BigInt、NaN、Infinity 等，序列化后会变成普通对象或丢失信息。

3. 循环引用会报错
   如果对象内部有循环引用（自己引用自己），会抛出 TypeError。

4. 原型链丢失
   拷贝后的对象原型链会变成 Object，原有的类实例信息丢失。

5. 只能处理可序列化的数据
   如 DOM 节点、函数、特殊对象等都无法正确拷贝。

#### 实现 Promise

```js
class MyPromise {
  constructor(execute) {
    this.status = "pending";
    this.resolveValue = undefined;
    this.rejectValue = undefined;
    this.fulfilledCallBacks = [];
    this.rejectedCallBacks = [];
    const resolve = (value) => {
      if (this.status === "pending") {
        this.status = "fulfilled";
        this.resolveValue = value;
        this.fulfilledCallBacks.forEach((cb) => {
          if (cb) setTimeout(() => cb(this.resolveValue));
        });
      }
    };
    const reject = (value) => {
      if (this.status === "pending") {
        this.status = "rejected";
        this.rejectValue = value;
        this.rejectedCallBacks.forEach((cb) => {
          if (cb) setTimeout(() => cb(this.rejectValue));
        });
      }
    };
    try {
      execute(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  then = (fulfilledCB, rejectedCB) => {
    return new MyPromise((resolve, reject) => {
      const onFulfilled = (value) => {
        let result = fulfilledCB ? fulfilledCB(value) : value;
        if (result instanceof MyPromise) {
          result.then(resolve, reject);
        } else {
          resolve(result);
        }
      };
      const onRejected = (reason) => {
        let result = rejectedCB ? rejectedCB(reason) : undefined;
        if (result instanceof MyPromise) {
          result.then(resolve, reject);
        } else {
          rejectedCB ? resolve(result) : reject(reason);
        }
      };
      if (this.status === "fulfilled") {
        setTimeout(() => onFulfilled(this.resolveValue));
      } else if (this.status === "rejected") {
        setTimeout(() => onRejected(this.rejectValue));
      } else {
        if (typeof fulfilledCB === "function") {
          this.fulfilledCallBacks.push(onFulfilled);
        }
        if (typeof rejectedCB === "function") {
          this.rejectedCallBacks.push(onRejected);
        }
      }
    });
  };
  catch = (rejectedCB) => {
    return this.then(null, rejectedCB);
  };
}
```

实现了最小可用的 Promise 内核：状态管理、链式调用、错误冒泡、finally 与静态 resolve/reject，使用 microtask 模拟原生异步执行队列。

#### 实现 Promise.all

```js
function promiseAll(iterable) {
  if (!iterable || typeof iterable[Symbol.iterator] !== "function")
    throw new TypeError("参数必须是可迭代对象");

  return new Promise((resolve, reject) => {
    const promises = Array.from(iterable);
    const results = [];
    let settledCount = 0;
    const total = promises.length;

    if (total === 0) {
      resolve(results);
      return;
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          settledCount += 1;
          if (settledCount === total) resolve(results);
        })
        .catch(reject);
    });
  });
}
```

先将可迭代对象转为数组获取长度和索引，使用 `forEach` 确保每个 Promise 的索引准确对应。由于 `then` 是异步的，在所有 Promise 创建后才会执行回调，此时 `total` 已确定。当任意 Promise 拒绝时立即拒绝整体。

#### 实现 call

```js
Function.prototype.myCall = function (context, ...args) {
  if (typeof this !== "function") throw new TypeError("myCall 必须由函数调用");
  const receiver =
    context === null || context === undefined ? globalThis : Object(context);
  const key = Symbol("fn");
  receiver[key] = this; // receiver[key]就是调用的那个函数 例如show
  const result = receiver[key](...args);
  delete receiver[key];
  return result;
};
function show(a, b) {
  console.log(this.x, a, b);
}
show.call({ x: "张三" }, 1, 2);
```

临时在目标对象上挂载函数避免属性名冲突，利用 Symbol 隔离，保证 null/undefined 时自动指向全局对象。

#### 实现防抖（debounce）与节流（throttle）

**防抖（debounce）**：高频事件触发时，只有最后一次触发后经过 n 毫秒才会执行回调。常用于输入框实时搜索、窗口 resize 等。

```js
function debounce(fn, delay = 300) {
  let timer = null;
  return function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

**节流（throttle）**：高频事件触发时，保证 n 毫秒内只会执行一次回调。常用于滚动、拖拽、页面 resize 等场景。

```js
function throttle(fn, delay = 300) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime > delay) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}
```

// 用法示例
window.addEventListener('scroll', throttle(() => {
console.log('滚动事件触发');
}, 500));

// 防抖和节流的区别：
// 防抖关注“最后一次”触发，节流关注“每隔一段时间”触发一次。

#### 给定 n 个数中随机取出 m 个数，要求等概率

```js
function sampleSubsetEqualProbability(arr, m) {
  if (!Array.isArray(arr)) throw new TypeError("参数必须是数组");
  const n = arr.length;
  if (m < 0 || m > n) throw new RangeError("m 需要满足 0 ≤ m ≤ 数组长度");

  const pool = arr.slice();
  for (let i = 0; i < m; i++) {
    const j = i + Math.floor(Math.random() * (n - i));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  return pool.slice(0, m);
}
```

使用局部 Fisher-Yates 洗牌，仅对前 m 个位置执行置换操作，能保证每个组合出现概率一致。复制原数组后再操作，避免修改输入。时间复杂度为 O(n)，空间复杂度为 O(n)。
当参数无效时会抛出中文错误提示，便于调用方快速定位问题。
