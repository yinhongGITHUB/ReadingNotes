### 什么是动态规划的算法题？

动态规划（Dynamic Programming，简称 DP）是一种将复杂问题分解为更小子问题、并保存子问题结果以避免重复计算的算法思想。

动态规划算法题的特点：

- 问题可以分解为重叠的子问题（子问题之间有重叠）
- 存在最优子结构（整体最优解可以由子问题的最优解推导）
- 适合用递归+记忆化或迭代+状态表（数组/矩阵）来求解

常见类型：

- 最值问题（最大/最小/最优方案）：如背包问题、最长上升子序列、最短路径
- 计数问题：如不同路径数、分割方案数
- 匹配问题：如字符串编辑距离、正则匹配

经典例子：

1. 斐波那契数列
2. 背包问题（0-1 背包、完全背包）
3. 最长公共子序列/子串
4. 爬楼梯问题

解题步骤：

1. 明确状态（dp[i] 或 dp[i][j] 表示什么）
2. 状态转移方程（递推公式）
3. 初始化
4. 遍历顺序
5. 返回答案

动态规划的核心是“用空间换时间”，通过保存子问题结果，极大提升效率。

---

#### 动态规划常见例子与切入思路

1. 斐波那契数列

   - 问题：f(n) = f(n-1) + f(n-2)，求第 n 项。
   - 切入：dp[i] 表示第 i 项，状态转移 dp[i] = dp[i-1] + dp[i-2]。

2. 爬楼梯问题

   - 问题：每次可以爬 1 或 2 阶，n 阶有多少种爬法？
   - 切入：dp[i] 表示到第 i 阶的方法数，dp[i] = dp[i-1] + dp[i-2]。

3. 0-1 背包问题

   - 问题：给定物品重量和价值，背包容量有限，如何装最大价值？
   - 切入：dp[i][j] 表示前 i 个物品、容量为 j 时的最大价值，状态转移：选或不选第 i 个物品。

4. 最长上升子序列

   - 问题：数组中最长递增子序列长度。
   - 切入：dp[i] 表示以第 i 个数结尾的最长递增子序列长度，遍历前面所有 j < i，若 nums[j] < nums[i]，则 dp[i] = max(dp[i], dp[j]+1)。

5. 最小路径和
   - 问题：网格左上到右下，每次只能向右或下，路径和最小。
   - 切入：dp[i][j] 表示到 (i,j) 的最小路径和，dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]。

---

切入动态规划问题的常用思路：

1. 明确“状态”——用什么变量描述子问题？
2. 写出“状态转移方程”——当前状态如何由子状态推导？
3. 明确“初始值”——最小子问题的解是什么？
4. 明确“遍历顺序”——一维/二维、正序/倒序？
5. 返回“最终答案”——通常是 dp[n] 或 dp[n][m]。

遇到“最优解/方案数/计数/匹配”类问题，优先考虑能否用动态规划建模。

---

#### 例题：最少删除多少个 a，使得不存在 i < j 且 str[i] = 'a' 且 str[j] = 'b'

题目描述：
给定一个只包含 'a' 和 'b' 的字符串 str，每次可以删除一个 'a'，问最少删除多少次 'a'，使得不存在下标 i < j，str[i] = 'a' 且 str[j] = 'b'。

换句话说，最终字符串中不能出现 'a' 在 'b' 之前的情况，即所有的 'a' 必须都在所有的 'b' 之后。

思路分析：

- 动态规划/贪心都可。
- 从左到右遍历，遇到 'b' 记录 b 的数量，遇到 'a' 可以选择删掉（代价+1），或者保留（但会和后面的 b 冲突）。
- 维护一个 dp，dp[i] 表示前 i 个字符最少删除多少个 'a'。

更简单的贪心做法：

- 从左到右遍历，遇到 'a'，可以选择删掉（删除次数+1），遇到 'b'，可以选择把前面的 'a' 都删掉，或者把当前 'b' 变成 'a'（但题目只允许删 'a'）。
- 实际上，遍历时维护一个 bCount，遇到 'a' 时，答案为 min(当前删除次数+1, bCount)。

代码示例：

```js
function minDeleteA(str) {
  let res = 0; // 最少删除次数
  let bCount = 0; // 已经遇到的 b 的数量
  for (let c of str) {
    if (c === "a") {
      // 要么删掉这个 a（res+1），要么保留（但会和后面的 b 冲突）
      res = Math.min(res + 1, bCount);
    } else {
      bCount++;
    }
  }
  return res;
}
// 示例
test = "aabbabbba";
console.log(minDeleteA(test)); // 输出：2
```

解释：

- 只需删除第 3 个和第 5 个 'a'，剩下的 'a' 都在所有 'b' 之后。

这种题的切入点：

- 先明确最终目标（所有 'a' 必须在所有 'b' 之后）
- 考虑每个字符的决策（删/不删）
- 用贪心或 dp 维护最优解
