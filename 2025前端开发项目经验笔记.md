#### 渲染 md 文件

1. 拿到字符串的 md 文件

```js
axios.get(
'/README.md',
params:{...params},
headers:{},
responseType: 'text'
).then((md: string) => {
console.log(md); // md 文件内容（字符串）
});
```

2. 拿到转换成 HTML 字符串

```js
function simpleMarkdown(md: string): string {
md = md.replace(/^###### (.)$/gm, '<h6>$1</h6>');
md = md.replace(/^##### (.)$/gm, '<h5>$1</h5>');
md = md.replace(/^#### (.)$/gm, '<h4>$1</h4>');
md = md.replace(/^### (.)$/gm, '<h3>$1</h3>');
md = md.replace(/^## (.)$/gm, '<h2>$1</h2>');
md = md.replace(/^# (.)$/gm, '<h1>$1</h1>');
md = md.replace(/**(.?)**/g, '<strong>$1</strong>');
md = md.replace(/*(.?)*/g, '<em>$1</em>');
md = md.replace(/[(.?)]((.?))/g, '<a href="$2">$1</a>');
md = md.replace(/^\s*[-] (.)$/gm, '<li>$1</li>');
md = md.replace(/(<li>.\*</li>)/g, '<ul>$1</ul>');
md = md.replace(/\n/g, '<br>');
return md;
}
```

3. v-html 渲染

#### params 传参注意点：

1. 动态路由参数（路径参数）
   路径中声明（如/user/:id）
   参数成为 URL 的一部分（如/user/123）
   刷新后，数据保留，（URL 不变）
2. 编程式导航的 params（临时状态）（不推荐使用）
   无需在路径中声明（如/user）
   URL 中不显示参数（如/user）
   刷新后数据丢失（内存数据被清空）
   直接 router.push({ name: 'detail', params: { id: 123 } })

#### 渲染顺序

同一组件：script → template → style
父组件 A 里面有两个子组件 B C， B 组件在 C 组件的上面
创建顺序（setup/created）：A → B → C
挂载顺序（mounted）：B → C → A
卸载顺序（unmounted）：C → B → A
父组件销毁时，会先销毁所有子组件，再销毁自己。
而对于同一层级的多个子组件（如 B、C），Vue 会按“渲染顺序的逆序”依次销毁，即先销毁后渲染的组件。

#### node.js 的全局对象

process 是 Node.js 的全局对象，常用属性和方法有：

process.env：环境变量对象
process.argv：命令行参数数组
process.cwd()：当前工作目录
process.exit([code])：退出进程
process.pid：当前进程 ID
process.platform：操作系统平台（如 'win32', 'linux'）
process.version：Node.js 版本
process.versions：依赖库版本信息
process.memoryUsage()：内存使用情况
process.uptime()：进程运行时间
process.nextTick()：下一个事件循环执行函数
process.stdin / process.stdout / process.stderr：标准输入/输出/错误流
process.on(event, callback)：监听进程事件（如 'exit', 'uncaughtException'）

#### Vue 3 的生命周期

setup 不能用 this
beforeCreate 能访问 this，但没有数据
created 及以后能访问 this 和所有数据,如 data props

1. 创建阶段
   setup()

组合式 API 的入口，响应式数据、方法、生命周期都在这里声明。
特征：此时还没有 DOM，不能访问 this。
beforeCreate（选项式 API）

数据和事件尚未初始化，访问不到 data、props、methods。
(this 在 beforeCreate 阶段已经可以访问，但此时还拿不到 data、props、methods 等数据)
created

数据已初始化，可以访问响应式数据(即可以拿到 this.data)，但还没有 DOM。 2. 挂载阶段
beforeMount

模板已编译，但还未挂载到真实 DOM。
mounted

组件已挂载到页面，可以访问和操作真实 DOM。
特征：适合做 DOM 操作、请求接口、第三方库初始化。 3. 更新阶段
beforeUpdate

响应式数据变化，DOM 更新前触发。
updated

DOM 更新后触发，可以获取最新的页面状态。
特征：适合做依赖 DOM 的后处理。 4. 卸载阶段
beforeUnmount

组件即将被卸载，适合做清理工作。
unmounted

组件已被卸载，所有事件、定时器等都应清理完毕。

你在 createApp 中使用字符串模板创建 Vue 实例，但是你的项目是基于 Vite + TypeScript 构建的，默认情况下生产环境不包含模板编译器。在开发环境下，Vite 会自动处理模板编译，但打包后的生产版本默认使用 runtime-only 版本的 Vue，不包含模板编译器。我对这块很感兴趣 详细介绍一下

#### 动态实现瀑布流而且还图片懒加载

```js
<template>
<img
    v-for="img in imgList"
    :key="img.id"
    :data-src="img.url"
    alt="图片"
    class="lazy-img"
    width="200"
    height="150"
  />
</template>

<script setup lang="ts">
import { onMounted } from 'vue';

const imgList = [
  { id: 1, url: 'https://example.com/1.jpg' },
  { id: 2, url: 'https://example.com/2.jpg' },
  // ...
];

onMounted(() => {
  const imgs = document.querySelectorAll('.lazy-img');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        img.src = img.dataset.src || '';
        observer.unobserve(img); // 加载后取消监听
      }
    });
  });

  imgs.forEach(img => observer.observe(img));
});
</script>

screenSource.value?.forEach((item) => {
if ((item.id = 'imageModule')) {
uni
.createSelectorQuery()
.select(`.img-${item.config.data}`)
.boundingClientRect((rect) => {
const imgHeight = rect?.bottom - rect?.top;

          // 计算图片在屏幕内的可见高度
          const visibleHeight = Math.min(rect?.bottom, screenHeight.value) - Math.max(rect?.top, 0);

          // 判断图片一半是否出现在可视区域
          if (visibleHeight >= imgHeight / 2 && rect?.bottom > 0 && rect?.top < screenHeight.value) {
            console.log('图片有一半及以上出现在可视区域', {
              img: item.config.data,
              visibleHeight,
              imgHeight,
              rect,
            });
          }
        })
        .exec();
    }

});
```

#### jsx/tsx 的渲染限制

不能直接返回组件，可以用 h 渲染一下再返回
不能直接使用 vue 语法 v-for v-if

#### 箭头函数的特点

1. 没有自己的 this
   箭头函数不会创建自己的 this，内部 this 继承自外层作用域（词法作用域）。
   适合用在回调、定时器等场景，避免 this 指向混乱。

2. 没有 arguments 对象
   箭头函数内部没有 arguments，需用 rest 参数 ...args 获取参数。

3. 不能作为构造函数
   不能用 new 调用箭头函数，否则会报错。

4. 没有 prototype 属性
   箭头函数没有 prototype，不能用作类（这里的类指的是**构造函数**）或原型方法。

5. 不能使用 super 和 new.target
   箭头函数内部不能用 super 和 new.target。

#### new.target

new.target 是 ES6 引入的一个元属性，用于在构造函数或类的构造器内部，判断当前函数是否通过 new 关键字被调用，以及获取实际被 new 的构造函数。
new.target → 构造函数引用（不是实例）
常见用法：

```js
function Person() {
  if (!new.target) {
    throw new Error("必须使用 new 调用");
  }
}
new Person(); // 正常
Person(); // 报错
```

#### 什么是构造函数引用

```js
function Foo() {}
const ref = Foo; // 这里的 ref 就是构造函数引用
const obj = new Foo(); // obj 是实例对象

function Bar() {
  console.log(new.target === Bar); // true
}
new Bar(); // 构造函数引用就是 Bar 本身
```

##### 可以在构造函数或类里面用 new.target 实例化对象吗？不能

```js
function Bar() {
  const obj = new new.target(); // ❌ 这样会报错
}
```

#### axios 如何取消请求

```js
// 创建 AbortController 实例
const controller = new AbortController();
/**
 * 发起 axios 请求并传入 signal
 * signal: controller.signal 让 axios 请求支持被中断。
 * 如果请求被取消，catch 会捕获到异常，axios.isCancel(err) 判断是否为取消类型。
 */
axios.get("/api/data", { signal: controller.signal }).catch((err) => {
  if (axios.isCancel(err)) {
    console.log("请求被取消");
  }
});

// 取消请求
controller.abort();
```

#### 短路表达式

```js
isReady && doSomething();
isError || retry();

// 还可以用来解构赋值
{
...(isReady&&{name:'张三'})
}
```
