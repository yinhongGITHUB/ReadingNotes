#### 渲染 md 文件

1. 获取 md 文件内容（字符串）

```js
// 方式一：静态导入（推荐 - 编译时确定）
// 适用场景：文件路径固定，放在 src/assets 下
import mdContent from "@/assets/README.md?raw";

// 方式二：动态导入（异步加载）
// 适用场景：需要按需加载或路径动态拼接
const loadMd = async (fileName: string) => {
  const md = await import(`@/assets/${fileName}.md?raw`);
  return md.default;
};

// 方式三：fetch 请求（运行时获取）
// 适用场景：文件放在 public 目录，作为静态资源
fetch("/README.md")
  .then((res) => res.text())
  .then((mdContent) => console.log(mdContent));
```

2. 转换成 HTML 字符串

```js
// 简单版：使用正则表达式手动解析（适合轻量场景）
function simpleMarkdown(md: string): string {
  md = md.replace(/^###### (.*)$/gm, "<h6>$1</h6>");
  md = md.replace(/^##### (.*)$/gm, "<h5>$1</h5>");
  md = md.replace(/^#### (.*)$/gm, "<h4>$1</h4>");
  md = md.replace(/^### (.*)$/gm, "<h3>$1</h3>");
  md = md.replace(/^## (.*)$/gm, "<h2>$1</h2>");
  md = md.replace(/^# (.*)$/gm, "<h1>$1</h1>");
  md = md.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>"); // 粗体
  md = md.replace(/\*(.+?)\*/g, "<em>$1</em>"); // 斜体
  md = md.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>'); // 链接
  md = md.replace(/^\s*[-*] (.*)$/gm, "<li>$1</li>"); // 列表项
  md = md.replace(/(<li>.*<\/li>)/g, "<ul>$1</ul>"); // 包裹列表
  md = md.replace(/\n/g, "<br>");
  return md;
}

// 专业版：使用 markdown-it 库（推荐 - 功能完整）
// npm install markdown-it
import MarkdownIt from "markdown-it";
const md = new MarkdownIt();
const html = md.render(mdContent);
```

3. 在组件中渲染

```vue
<template>
  <div class="markdown-content" v-html="htmlContent"></div>
</template>

<script setup lang="ts">
import { ref, onMounted } from "vue";
import mdContent from "@/assets/README.md?raw";

const htmlContent = ref("");

onMounted(() => {
  htmlContent.value = simpleMarkdown(mdContent);
});
</script>

<style>
/* 为 markdown 内容添加样式 */
.markdown-content h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
.markdown-content h2 {
  font-size: 1.5em;
  margin: 0.75em 0;
}
.markdown-content code {
  background: #f5f5f5;
  padding: 2px 4px;
}
.markdown-content a {
  color: #42b983;
  text-decoration: none;
}
</style>
```

**注意事项：**

- 使用 `v-html` 渲染时需注意 XSS 安全问题，确保 md 内容可信
- `?raw` 后缀是 Vite 特有功能，告诉 Vite 以字符串形式导入文件
- 简单正则方案不支持代码块、表格等复杂语法，生产环境建议用 `markdown-it`

#### params 传参注意点：

1. 动态路由参数（路径参数）
   路径中声明（如/user/:id）
   参数成为 URL 的一部分（如/user/123）
   刷新后，数据保留，（URL 不变）
2. 编程式导航的 params（临时状态）（不推荐使用）
   无需在路径中声明（如/user）
   URL 中不显示参数（如/user）
   刷新后数据丢失（内存数据被清空）
   直接 router.push({ name: 'detail', params: { id: 123 } })

#### 渲染顺序

同一组件：script → template → style
父组件 A 里面有两个子组件 B C， B 组件在 C 组件的上面
创建顺序（setup/created）：A → B → C
挂载顺序（mounted）：B → C → A
卸载顺序（unmounted）：C → B → A
父组件销毁时，会先销毁所有子组件，再销毁自己。
而对于同一层级的多个子组件（如 B、C），Vue 会按“渲染顺序的逆序”依次销毁，即先销毁后渲染的组件。

#### node.js 的全局对象

process 是 Node.js 的全局对象，常用属性和方法有：

process.env：环境变量对象
process.argv：命令行参数数组
process.cwd()：当前工作目录
process.exit([code])：退出进程
process.pid：当前进程 ID
process.platform：操作系统平台（如 'win32', 'linux'）
process.version：Node.js 版本
process.versions：依赖库版本信息
process.memoryUsage()：内存使用情况
process.uptime()：进程运行时间
process.nextTick()：下一个事件循环执行函数
process.stdin / process.stdout / process.stderr：标准输入/输出/错误流
process.on(event, callback)：监听进程事件（如 'exit', 'uncaughtException'）

#### Vue 3 的生命周期

setup 不能用 this
beforeCreate 能访问 this，但没有数据
created 及以后能访问 this 和所有数据,如 data props

1. 创建阶段
   setup()

组合式 API 的入口，响应式数据、方法、生命周期都在这里声明。
特征：此时还没有 DOM，不能访问 this。
beforeCreate（选项式 API）

数据和事件尚未初始化，访问不到 data、props、methods。
(this 在 beforeCreate 阶段已经可以访问，但此时还拿不到 data、props、methods 等数据)
created

数据已初始化，可以访问响应式数据(即可以拿到 this.data)，但还没有 DOM。 2. 挂载阶段
beforeMount

模板已编译，但还未挂载到真实 DOM。
mounted

组件已挂载到页面，可以访问和操作真实 DOM。
特征：适合做 DOM 操作、请求接口、第三方库初始化。 3. 更新阶段
beforeUpdate

响应式数据变化，DOM 更新前触发。
updated

DOM 更新后触发，可以获取最新的页面状态。
特征：适合做依赖 DOM 的后处理。 4. 卸载阶段
beforeUnmount

组件即将被卸载，适合做清理工作。
unmounted

组件已被卸载，所有事件、定时器等都应清理完毕。

你在 createApp 中使用字符串模板创建 Vue 实例，但是你的项目是基于 Vite + TypeScript 构建的，默认情况下生产环境不包含模板编译器。在开发环境下，Vite 会自动处理模板编译，但打包后的生产版本默认使用 runtime-only 版本的 Vue，不包含模板编译器。我对这块很感兴趣 详细介绍一下

#### 动态实现瀑布流而且还图片懒加载

```js
<template>
<img
    v-for="img in imgList"
    :key="img.id"
    :data-src="img.url"
    alt="图片"
    class="lazy-img"
    width="200"
    height="150"
  />
</template>

<script setup lang="ts">
import { onMounted } from 'vue';

const imgList = [
  { id: 1, url: 'https://example.com/1.jpg' },
  { id: 2, url: 'https://example.com/2.jpg' },
  // ...
];

onMounted(() => {
  const imgs = document.querySelectorAll('.lazy-img');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        img.src = img.dataset.src || '';
        observer.unobserve(img); // 加载后取消监听
      }
    });
  });

  imgs.forEach(img => observer.observe(img));
});
</script>

screenSource.value?.forEach((item) => {
if ((item.id = 'imageModule')) {
uni
.createSelectorQuery()
.select(`.img-${item.config.data}`)
.boundingClientRect((rect) => {
const imgHeight = rect?.bottom - rect?.top;

          // 计算图片在屏幕内的可见高度
          const visibleHeight = Math.min(rect?.bottom, screenHeight.value) - Math.max(rect?.top, 0);

          // 判断图片一半是否出现在可视区域
          if (visibleHeight >= imgHeight / 2 && rect?.bottom > 0 && rect?.top < screenHeight.value) {
            console.log('图片有一半及以上出现在可视区域', {
              img: item.config.data,
              visibleHeight,
              imgHeight,
              rect,
            });
          }
        })
        .exec();
    }

});
```

#### jsx/tsx 的渲染限制

不能直接返回组件，可以用 h 渲染一下再返回
不能直接使用 vue 语法 v-for v-if

#### 箭头函数的特点

1. 没有自己的 this
   箭头函数不会创建自己的 this，内部 this 继承自外层作用域（词法作用域）。
   适合用在回调、定时器等场景，避免 this 指向混乱。

2. 没有 arguments 对象
   箭头函数内部没有 arguments，需用 rest 参数 ...args 获取参数。

3. 不能作为构造函数
   不能用 new 调用箭头函数，否则会报错。

4. 没有 prototype 属性
   箭头函数没有 prototype，不能用作类（这里的类指的是**构造函数**）或原型方法。

5. 不能使用 super 和 new.target
   箭头函数内部不能用 super 和 new.target。

#### new.target

new.target 是 ES6 引入的一个元属性，用于在构造函数或类的构造器内部，判断当前函数是否通过 new 关键字被调用，以及获取实际被 new 的构造函数。
new.target → 构造函数引用（不是实例）
常见用法：

```js
function Person() {
  if (!new.target) {
    throw new Error("必须使用 new 调用");
  }
}
new Person(); // 正常
Person(); // 报错
```

#### 什么是构造函数引用

```js
function Foo() {}
const ref = Foo; // 这里的 ref 就是构造函数引用
const obj = new Foo(); // obj 是实例对象

function Bar() {
  console.log(new.target === Bar); // true
}
new Bar(); // 构造函数引用就是 Bar 本身
```

##### 可以在构造函数或类里面用 new.target 实例化对象吗？不能

```js
function Bar() {
  const obj = new new.target(); // ❌ 这样会报错
}
```

#### axios 如何取消请求

```js
// 创建 AbortController 实例
const controller = new AbortController();
/**
 * 发起 axios 请求并传入 signal
 * signal: controller.signal 让 axios 请求支持被中断。
 * 如果请求被取消，catch 会捕获到异常，axios.isCancel(err) 判断是否为取消类型。
 */
axios.get("/api/data", { signal: controller.signal }).catch((err) => {
  if (axios.isCancel(err)) {
    console.log("请求被取消");
  }
});

// 取消请求
controller.abort();
```

#### 短路表达式

```js
// isReady为true  就执行doSomething
isReady && doSomething();
// isError为false 就执行retry
isError || retry();

// 还可以用来解构赋值
{
...(isReady&&{name:'张三'})
}
```

#### 补丁文件

一般根目录下的 patches 文件夹，里面创建一个文件，自定义名字规则如下：
文件名一般形如 **包名+版本号.patch**，内容是标准的 diff/patch 格式。
例如： package.json 文件里面的依赖包 "@dcloudio/uni-ui": "1.4.22", 则文件名应该设置成：@dcloudio+uni-ui+1.4.22.patch 表示对 @dcloudio/uni-ui@1.4.22 的补丁。

#### 是否选中元素的文本以及是否成为鼠标、触摸的目标

user-select 用于控制用户是否可以选中元素的文本
pointer-events 是一个 CSS 属性，用于控制元素是否能成为鼠标、触摸等指针事件的目标。设置 pointer-events: none; 后，元素及其子元素都无法被点击、hover、拖拽等

git 命令  
cherry pick

#### 两种代码回退方式

- git reset---
  git reset --soft B：只回退 commit，代码内容还在（C、D 的更改会留在暂存区，无需 git add ，commit 消失）。
  git reset --mixed B（默认）：回退 commit（C、D 的更改会留在工作区，需要 git add），代码内容还在工作区（未提交的更改还在）。
  git reset --hard B：回退 commit、暂存区和工作区，C、D 的所有更改和代码都被彻底清除，什么都不剩。

- git revert----

假设：

C 提交里新增了变量 a。
D 提交里用到了变量 a。
你现在 git revert C，生成了 E 提交，E 会把 C 的更改（比如新增变量 a）“反做”，也就是把变量 a 删除。
“反做”指定提交，意思是：把某个 commit（提交）里做的所有更改，全部反向操作一遍。
举例说明：

如果 C 提交是“新增变量 a”，那么“反做”就是“删除变量 a”。
如果 C 提交是“把变量 b 的值从 1 改成 2”，那么“反做”就是“把变量 b 的值从 2 改回 1”。
如果 C 提交是“删除了一行代码”，那么“反做”就是“把那行代码加回来”。

#### 规范化团队代码格式

总结：
lint-staged 保证代码质量
commitizen 保证提交信息规范、易写
commitlint 保证提交信息格式
husky 串联整个流程

1. .husky —— Git 钩子管理工具
   作用：让你可以方便地在 git 的各个阶段（如 commit、push）自动执行脚本。
   常见用法：自动在提交前/后、推送前/后执行检查、格式化、校验等任务。
   配置方式：在项目根目录下有 .husky 文件夹，每个钩子（如 pre-commit、commit-msg）对应一个 shell 脚本文件。
   示例：pre-commit 里写 pnpm lint:lint-staged，表示每次提交前自动执行 lint-staged 检查。
   pre-commit：在执行 git commit 前触发。常用于检查代码格式、运行 lint、自动修复代码等，防止不合格的代码被提交。
   commit-msg：在输入完提交信息、但还未真正提交时触发。常用于校验提交信息格式（如是否符合 Conventional Commits 规范），不合格则阻止提交
2. lint-staged —— 只检查/修复暂存区的文件（即 pre-commit 阶段）
   作用：只对 git 暂存区（即将要提交的）文件执行 lint、格式化等操作，提升效率，避免全量检查。
   常见用法：配合 husky 的 pre-commit 钩子，保证提交的代码都是格式化和通过 lint 的。
   配置方式：在 package.json 的 lint-staged 字段或单独的 .lintstagedrc 文件。
   示例：pnpm lint:lint-staged 实际会运行 lint-staged，自动修复并格式化即将提交的代码。
   ```js
   // package.json文件里面
   "lint-staged": {
   "*.{js,ts,jsx,tsx,vue}": [
    "eslint --fix",
    "prettier --write"
   ],
   "*.{json,md,html}": [
    "prettier --write"
   ]
   }
   ```
3. commitlint —— 校验提交信息格式
   作用：检查你的 commit message 是否符合团队/项目的规范（如 Conventional Commits）。
   常见用法：配合 husky 的 commit-msg 钩子，阻止不规范的提交信息进入仓库。
   配置方式：commitlint.config.mjs 或 .commitlintrc 文件。
   示例：提交信息不规范（如缺少 scope）会被拒绝提交。
   husky 的 commit-msg 文件里面
   #!/usr/bin/env sh
   . "$(dirname -- "$0")/\_/husky.sh"
   pnpm exec commitlint --edit $1

4. commitizen（及 git-cz/cz-git）—— 交互式生成规范提交信息
   作用：让你不用手写 commit message，通过交互式问答生成规范的提交说明。
   常见用法：运行 npm run commit 或 git-cz，选择 type、scope、输入描述，自动生成规范 commit。
   配置方式：package.json 的 config.commitizen 字段，指定适配器（如 cz-git）。
   示例：生成 feat(模块): 新增功能 这样的规范提交信息。

#### pnpm 管理包

pnpm 采用“全局内容寻址存储 + 项目本地硬链接”的方式管理依赖，核心机制如下：

1. 全局存储（store）
   所有下载的包都会被缓存到全局的 pnpm store 目录（如 ~/.pnpm-store），同一个包的不同版本只下载一次，节省磁盘空间。

2. 项目 node_modules 结构
   pnpm 在项目的 node_modules 里只创建包的“硬链接”指向全局 store，实际文件只存一份。
   node_modules 采用“虚拟目录+符号链接”结构，保证依赖树扁平但隔离，防止幽灵依赖。

3. 严格依赖解析
   pnpm v7+ 默认启用严格模式，只有在 package.json 明确声明的依赖才能被项目代码直接引用，间接依赖不能直接用，避免幽灵依赖。

4. hoist pattern（可选）
   pnpm 支持 hoist（提升）部分依赖到 node_modules 根目录，兼容一些老旧工具，但默认依然是隔离依赖。

5. 多项目/monorepo 支持
   pnpm 支持 workspace，多个项目共享同一个 store，依赖复用更高效。

总结：pnpm 通过全局缓存+硬链接+严格依赖声明，既节省空间又保证依赖安全，避免了 npm/yarn 时代常见的依赖混乱和幽灵依赖问题。

#### Three.js

three.js 是一个基于 WebGL 封装的 3D 渲染 JavaScript 库，能让开发者用极少的代码在网页上实现复杂的 3D 场景、动画和交互。它屏蔽了底层 WebGL 的复杂性，提供了丰富的 3D 对象、灯光、材质、相机、控制器等 API，适合快速开发 3D 可视化、游戏、产品展示等应用。

待学习......

#### monorepo（单体仓库）

monorepo 的核心思想是：在一个代码仓库里统一管理多个子项目（比如前端、后端、组件库等），而不是每个项目单独一个仓库。

待学习......
