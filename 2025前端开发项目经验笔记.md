#### 配置开发分支合并主分支时。即 git merge 的时候打开 vim 看看自己本次到底修改了什么

git config --local merge.edit true 设置
git config --local --get merge.edit 查看设置

#### 针对一个 vue 文件

##### 编译阶段：

# npm run build 时发生的事情

1. TypeScript 类型检查
2. Vue SFC 编译 (template, script, style)
3. 依赖分析和打包
4. 静态资源处理（图片、字体等）
5. 代码压缩和优化
6. 生成最终的 bundle 文件

##### 运行阶段（浏览器中）：

// 1. 组件挂载时
const instance = createApp(OperationalReportOne);
// - Props 初始化
// - 计算属性求值
// - 模板首次渲染

// 2. 数据更新时  
currentRow.value = newData;
// - 响应式系统检测变化
// - 重新计算相关计算属性
// - 虚拟 DOM 对比
// - 更新真实 DOM

// 3. 用户交互时
// - 事件处理函数执行
// - 可能触发数据更新
// - 重新渲染相关部分

#### 学习下 Service Worker

#### Docker 构建缓存的本质

1. Dockerfile 每一行命令（如 COPY、RUN）都会生成一层镜像（layer）。
2. 只要这一行的输入内容没变，Docker 就会用上次构建时的缓存，不会重新执行。
3. 一旦某一层的输入变了，这一层和后面的所有层都会重新执行。
4. 先 COPY 依赖声明文件，再 RUN 安装依赖，最后 COPY 业务代码。
   这样 node_modules 只会在依赖变动时才重装，业务代码变动不会影响依赖缓存。

注意点：
.dockerignore 文件，去掉不必要文件 这样在 copy ..阶段 I/O 操作更少，速度更快
node_modules
dist
.git
.gitignore
Dockerfile
npm-debug.log
\*.md
.vscode
.env

#### 两种不同的项目部署方式

1. 直接把 dist 文件放到服务器
   流程：
   用本地或 CI 构建出 dist 文件夹。
   通过 scp、ftp、ssh、Jenkins 等方式，把 dist 目录上传到服务器的指定目录。
   服务器上通常已经有 nginx、Apache 或其它 Web 服务器，配置好静态目录即可访问。
   特点：
   服务器环境和 Web 服务（如 nginx）是提前装好的，dist 只是静态资源。
   部署快，操作简单，适合传统静态站点。
   服务器环境不易统一，容易出现“本地能跑，线上有问题”。
   需要手动或脚本维护服务器上的 nginx 配置、依赖等。
2. 镜像部署（Docker 镜像）
   流程：
   用 Dockerfile 构建镜像，把 dist 文件（或整个服务环境）打包进镜像（如多阶段构建+nginx）。
   镜像推送到镜像仓库，服务器用 docker run 启动容器，容器内自带 nginx 并自动 serve dist。
   一台服务器可以跑多个不同版本的镜像，环境完全隔离。
   特点：
   部署环境、依赖、Web 服务都封装在镜像里，环境一致性极高。
   易于回滚、扩容、迁移，适合云原生、K8s 等现代运维体系。
   只需启动容器即可访问，无需手动配置 nginx。
   初期学习和配置成本略高，但长期维护简单。

##### 镜像部署如果想自定义 nginx 配置如何做？

项目根目录新建一个 nginx.conf 文件，
然后在 Dockerfile 里面加上下面得命令
COPY nginx.conf /etc/nginx/conf.d/default.conf
把你自定义的 nginx 配置覆盖到 nginx 镜像的默认配置。

#### 鼠标事件相关属性（event）

clientX：鼠标相对于视口左上角的 X 坐标
clientY：鼠标相对于视口左上角的 Y 坐标
pageX：鼠标相对于整个文档左上角的 X 坐标（包含滚动距离）
pageY：鼠标相对于整个文档左上角的 Y 坐标
screenX：鼠标相对于屏幕左上角的 X 坐标
screenY：鼠标相对于屏幕左上角的 Y 坐标
offsetX：鼠标相对于事件源元素左上角的 X 坐标
offsetY：鼠标相对于事件源元素左上角的 Y 坐标
滚动相关属性（DOM 元素或 document）
scrollTop：元素已滚动的垂直距离（像素）
scrollLeft：元素已滚动的水平距离（像素）
scrollHeight：元素内容的总高度（包括未显示部分）
scrollWidth：元素内容的总宽度（包括未显示部分）
clientHeight：元素可视区域的高度（不含滚动条）
clientWidth：元素可视区域的宽度（不含滚动条）
offsetHeight：元素的高度（包括内边距和边框）
offsetWidth：元素的宽度（包括内边距和边框）

#### 渲染 md 文件

1. 拿到字符串的 md 文件

```js
axios.get(
'/README.md',
params:{...params},
headers:{},
responseType: 'text'
).then((md: string) => {
console.log(md); // md 文件内容（字符串）
});
```

2. 拿到转换成 HTML 字符串

```js
function simpleMarkdown(md: string): string {
md = md.replace(/^###### (.)$/gm, '<h6>$1</h6>');
md = md.replace(/^##### (.)$/gm, '<h5>$1</h5>');
md = md.replace(/^#### (.)$/gm, '<h4>$1</h4>');
md = md.replace(/^### (.)$/gm, '<h3>$1</h3>');
md = md.replace(/^## (.)$/gm, '<h2>$1</h2>');
md = md.replace(/^# (.)$/gm, '<h1>$1</h1>');
md = md.replace(/**(.?)**/g, '<strong>$1</strong>');
md = md.replace(/*(.?)*/g, '<em>$1</em>');
md = md.replace(/[(.?)]((.?))/g, '<a href="$2">$1</a>');
md = md.replace(/^\s*[-] (.)$/gm, '<li>$1</li>');
md = md.replace(/(<li>.\*</li>)/g, '<ul>$1</ul>');
md = md.replace(/\n/g, '<br>');
return md;
}
```

3. v-html 渲染

#### params 传参注意点：

1. 动态路由参数（路径参数）
   路径中声明（如/user/:id）
   参数成为 URL 的一部分（如/user/123）
   刷新后，数据保留，（URL 不变）
2. 编程式导航的 params（临时状态）（不推荐使用）
   无需在路径中声明（如/user）
   URL 中不显示参数（如/user）
   刷新后数据丢失（内存数据被清空）
   直接 router.push({ name: 'detail', params: { id: 123 } })

#### 渲染顺序

同一组件：script → template → style
父组件 A 里面有两个子组件 B C， B 组件在 C 组件的上面
创建顺序（setup/created）：A → B → C
挂载顺序（mounted）：B → C → A
卸载顺序（unmounted）：C → B → A
父组件销毁时，会先销毁所有子组件，再销毁自己。
而对于同一层级的多个子组件（如 B、C），Vue 会按“渲染顺序的逆序”依次销毁，即先销毁后渲染的组件。

#### 异步加载 js 文件

async：下载完立即执行，可能阻塞解析，适合独立脚本。
defer：下载完等 DOM 解析完再执行，不阻塞页面，推荐。

#### vite 的默认分包最小限制

vite 的 chunkSizeWarningLimit 默认为 500kb 超过会警告

#### node.js 的全局对象

process 是 Node.js 的全局对象，常用属性和方法有：

process.env：环境变量对象
process.argv：命令行参数数组
process.cwd()：当前工作目录
process.exit([code])：退出进程
process.pid：当前进程 ID
process.platform：操作系统平台（如 'win32', 'linux'）
process.version：Node.js 版本
process.versions：依赖库版本信息
process.memoryUsage()：内存使用情况
process.uptime()：进程运行时间
process.nextTick()：下一个事件循环执行函数
process.stdin / process.stdout / process.stderr：标准输入/输出/错误流
process.on(event, callback)：监听进程事件（如 'exit', 'uncaughtException'）

#### Vue 3 的生命周期

setup 不能用 this
beforeCreate 能访问 this，但没有数据
created 及以后能访问 this 和所有数据,如 data props

1. 创建阶段
   setup()

组合式 API 的入口，响应式数据、方法、生命周期都在这里声明。
特征：此时还没有 DOM，不能访问 this。
beforeCreate（选项式 API）

数据和事件尚未初始化，访问不到 data、props、methods。
(this 在 beforeCreate 阶段已经可以访问，但此时还拿不到 data、props、methods 等数据)
created

数据已初始化，可以访问响应式数据(即可以拿到 this.data)，但还没有 DOM。 2. 挂载阶段
beforeMount

模板已编译，但还未挂载到真实 DOM。
mounted

组件已挂载到页面，可以访问和操作真实 DOM。
特征：适合做 DOM 操作、请求接口、第三方库初始化。 3. 更新阶段
beforeUpdate

响应式数据变化，DOM 更新前触发。
updated

DOM 更新后触发，可以获取最新的页面状态。
特征：适合做依赖 DOM 的后处理。 4. 卸载阶段
beforeUnmount

组件即将被卸载，适合做清理工作。
unmounted

组件已被卸载，所有事件、定时器等都应清理完毕。

你在 createApp 中使用字符串模板创建 Vue 实例，但是你的项目是基于 Vite + TypeScript 构建的，默认情况下生产环境不包含模板编译器。在开发环境下，Vite 会自动处理模板编译，但打包后的生产版本默认使用 runtime-only 版本的 Vue，不包含模板编译器。我对这块很感兴趣 详细介绍一下

#### 动态实现瀑布流而且还图片懒加载

```js
<template>
<img
    v-for="img in imgList"
    :key="img.id"
    :data-src="img.url"
    alt="图片"
    class="lazy-img"
    width="200"
    height="150"
  />
</template>

<script setup lang="ts">
import { onMounted } from 'vue';

const imgList = [
  { id: 1, url: 'https://example.com/1.jpg' },
  { id: 2, url: 'https://example.com/2.jpg' },
  // ...
];

onMounted(() => {
  const imgs = document.querySelectorAll('.lazy-img');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        img.src = img.dataset.src || '';
        observer.unobserve(img); // 加载后取消监听
      }
    });
  });

  imgs.forEach(img => observer.observe(img));
});
</script>

screenSource.value?.forEach((item) => {
if ((item.id = 'imageModule')) {
uni
.createSelectorQuery()
.select(`.img-${item.config.data}`)
.boundingClientRect((rect) => {
const imgHeight = rect?.bottom - rect?.top;

          // 计算图片在屏幕内的可见高度
          const visibleHeight = Math.min(rect?.bottom, screenHeight.value) - Math.max(rect?.top, 0);

          // 判断图片一半是否出现在可视区域
          if (visibleHeight >= imgHeight / 2 && rect?.bottom > 0 && rect?.top < screenHeight.value) {
            console.log('图片有一半及以上出现在可视区域', {
              img: item.config.data,
              visibleHeight,
              imgHeight,
              rect,
            });
          }
        })
        .exec();
    }

});
```

#### css 环境变量

padding: env(safe-area-inset-top, 20px) env(safe-area-inset-right, 20px)
env(safe-area-inset-bottom, 20px) env(safe-area-inset-left, 20px);
用于适配刘海屏、异形屏等设备的安全区域

#### 文字省略号 css 设置

text-overflow: ellipsis;
超出部分用省略号 ... 显示（只对单行有效，配合 overflow: hidden 和 white-space: nowrap）。
overflow: hidden;
超出容器的内容隐藏，不显示。
display: -webkit-box;
让元素成为弹性盒子模型，支持多行截断（需要 Webkit 内核，适用于小程序和部分浏览器）。
-webkit-box-orient: vertical;
设置弹性盒子的排列方向为垂直方向。
-webkit-line-clamp: 1;
限制显示的行数为 1 行，超出部分用省略号显示。

#### 查看当前大小写敏感设置

git config core.ignorecase
输出 true：表示大小写不敏感
输出 false：表示大小写敏感

#### 一些关于类型的判断

```js
enum activeNameEnum {
store_key = 'store_label',
business_key = 'business_label',
}

// keyof typeof activeNameEnum 的类型是 "store_key" | "business_key"
type TabKeys = keyof typeof activeNameEnum;

// 用法示例
let tab: TabKeys;
tab = "store_key"; // 合法
tab = "business_key"; // 合法
// tab = "store_label"; // 不合法，类型检查会报错

let a: typeof activeNameEnum;
// a = activeNameEnum; // 合法
// a = activeNameEnum.store_label; // 不合法

let b: activeNameEnum;
// b = activeNameEnum.store_label; // 合法
// b = 'store_label'; // 合法
// b = activeNameEnum; // 不合法

git commit -m 提交信息时无法输入中文，是编码配置的问题
git config --global i18n.commitencoding utf-8
```

#### 分包组件：

```js
A 分包在 page.json 里面配置
"usingComponents": {
"uvip-year-card-use": "./page_shop/pay/components/uvip-year-card-use/index.vue",
"charging-rules-dialog": "./page_single/room/components/ChargingRulesDialog"
},
"componentPlaceholder": {
"uvip-year-card-use": "view",
"charging-rules-dialog": "view"
}
那么 B 分包的页面想用 A 分包的 uvip-year-card-use 可以直接 import，但是 B 分包的页面下的组件想用 A 分包的 uvip-year-card-use 就需要在 page.json 里面配置占位符
"componentPlaceholder": {
"uvip-year-card-use": "view",
}
```

#### jsx/tsx 的渲染限制

不能直接返回组件或者使用 vue 语法 v-for v-if，可以用 h 渲染一下再返回

#### ts 的索引签名

TypeScript 要求：数字索引签名的值类型，必须是字符串索引签名值类型的子类型。
因为在 JavaScript 中，所有的数字索引其实都会被转换为字符串索引（如 obj[1] 等价于 obj["1"]）。
所以 TypeScript 规定，字符串索引类型要兼容数字索引类型，否则会导致类型不安全。
举个例子：

```js
interface Example {
  [key: string]: Animal; // 字符串索引
  [index: number]: Dog; // 数字索引
}
obj[1]其实会去拿obj["1"],也就是说，输入obj[1]和obj["1"]拿到的值是同一个，但是，做类型检查时，obj["1"]是Animal，obj[1]是Dog，又由于拿obj[1]会被转化成obj["1"]，
也就意味着 Dog必须是Animal的子类型
```

#### ts 索引签名的三种类型

```js
interface Example {
  [key: string]: string;
  [key: number]: string;
  [key: symbol]: string;
}
```

#### 类的类型限制

implements 限制类的类型，但是只能约束 public 成员，不能约束 private 或 protected。

```js
interface Animal {
  name: string;
  speak(): void;
}

class Dog implements Animal {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
  speak() {
    console.log("汪汪");
  }
}
```

上例中，Dog 必须有 name 属性和 speak 方法，否则会报错。

#### 构造器签名

interface ClockConstructor {
new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
tick();
}
构造函数实例化之后，的实例对象必须是 ClockInterface 类型

#### CSS 选择器

##### 一、CSS 选择器类型

1. 基本选择器
   元素选择器：div、span、p 等，选中所有该标签元素。
   类选择器：.class，选中所有 class 属性包含 class 的元素。
   ID 选择器：#id，选中 id 属性为 id 的元素。
   通配符选择器：\*，选中页面上的所有元素（优先级最低）。
2. 属性选择器
   [attr]：选中有该属性的元素。
   [attr=value]：选中属性值等于 value 的元素。
   [attr^=value]：属性值以 value 开头。
   [attr$=value]：属性值以 value 结尾。
   [attr*=value]：属性值包含 value。
3. 伪类选择器
   状态伪类：:hover、:active、:focus、:visited 等。
   结构伪类：:first-child、:last-child、:nth-child(n)、:not()、:empty 等。
4. 伪元素选择器
   ::before、::after、::first-line、::first-letter 等。
5. 组合选择器
   后代选择器：A B，选中所有在 A 元素内的 B 元素（不限层级）。
   子选择器：A > B，选中所有作为 A 元素直接子元素的 B 元素。
   相邻兄弟选择器：A + B，选中紧跟在 A 元素后的第一个 B 元素。
   通用兄弟选择器：A ~ B，选中同一父元素下，A 元素后面的所有 B 元素。
   分组选择器：div, .class, #id，选中所有满足任一条件的元素。
6. 多同级选择器（复合类选择器）
   .a.b.c.d.e.f：选中同时拥有 a、b、c、d、e、f 这六个类名的元素。

##### 二、优先级（Specificity）详细规则

CSS 优先级由四个部分组成，分别用四位数字表示（a, b, c, d）：

优先级位 说明 计数方式
a 行内样式（style 属性） 每出现一次加 1
b ID 选择器（#id） 每出现一次加 1
c 类选择器（.class）、属性选择器（[attr]）、伪类（:hover） 每出现一次加 1
d 元素选择器（div）、伪元素（::before）、通配符（\*） 每出现一次加 1
优先级计算举例：

行内样式：style="color:red" → (1,0,0,0)

#header .nav li.active a:hover

#header：b=1
.nav、.active、:hover：c=3
li、a：d=2
总优先级：(0,1,3,2)
.a.b.c.d.e.f

6 个类选择器：c=6
总优先级：(0,0,6,0)
div

元素选择器：d=1
总优先级：(0,0,0,1)

-

通配符选择器：d=1（但实际优先级最低）
[type="text"]:focus

属性选择器：c=1
伪类选择器：c=1
总优先级：(0,0,2,0)
优先级比较规则：

先比较 a，再比较 b，再比较 c，最后比较 d。
优先级高的样式覆盖低优先级的样式。
优先级相同，后写的样式覆盖前面的样式（层叠性）。
!important 可强制提升优先级，覆盖所有普通样式（但不建议滥用）。

##### 三、浏览器默认样式

浏览器会为 HTML 元素设置默认样式（如 body 的 margin，h1 的 font-size）。
默认样式优先级最低，任何自定义样式都会覆盖它。
可以用 \_ { all: unset; } 或 reset.css/normalize.css 清除默认样式。

##### 四、多个同级选择器不加空格（如 .a.b.c.d.e.f）

.a.b.c.d.e.f 是复合类选择器，表示元素必须同时拥有 a、b、c、d、e、f 这六个类名。
优先级为 (0,0,6,0)，比单一类选择器高，比 ID 选择器低。
只有 <div class="a b c d e f"> 这样的元素会被选中。

##### 五、所有选择器优先级对比表

选择器类型 示例 优先级 (a,b,c,d)
行内样式 <div style="..."> (1,0,0,0)
ID 选择器 #id (0,1,0,0)
类选择器 .class (0,0,1,0)
属性选择器 [type="text"] (0,0,1,0)
伪类选择器 :hover (0,0,1,0)
元素选择器 div (0,0,0,1)
伪元素选择器 ::before (0,0,0,1)
通配符选择器 \_ (0,0,0,1)
复合类选择器 .a.b.c.d.e.f (0,0,6,0)
后代选择器 .a .b (0,0,2,0)
子选择器 .a > .b (0,0,2,0)
相邻兄弟选择器 .a + .b (0,0,2,0)
通用兄弟选择器 .a ~ .b (0,0,2,0)
分组选择器 div, .class (0,0,0,1)/(0,0,1,0)
!important color: red !important 覆盖所有

##### 总结：

CSS 选择器类型丰富，优先级由选择器类型和数量决定。
复合类选择器（如 .a.b.c.d.e.f）优先级较高，只有同时拥有所有类名的元素才会被选中。
通配符选择器优先级最低，常用于全局样式重置。
浏览器默认样式优先级最低，任何自定义样式都能覆盖。
优先级高的样式覆盖低优先级，!important 最高但应谨慎使用。

#### 开发中实例话一个 ref 组件对象时用到（const A = ref<InstanceType<typeof 组件名>>()）

Foo 是一个组件或者类
typeof Foo 得到的是“类的类型”或“组件的类型”（构造函数类型），不是实例类型。
InstanceType<typeof Foo> 得到的是“实例类型”，也就是 new Foo() 或 <Foo /> 组件实例的类型。

#### 条件类型 + infer 推断

```js
// 提取数组的元素类型
type ElementType<T> = T extends (infer U)[] ? U : T;

type A = ElementType<number[]>; // number
type B = ElementType<string>;   // string
type C = ElementType<boolean[]>; // boolean
// T extends (infer U)[]：判断 T 是否为数组类型（如 string[]、number[]），如果是，则用 infer U 推断出数组元素类型 U。? U : T：如果 T 是数组，则结果类型为 U（即数组元素类型）；如果 T 不是数组，则结果类型为 T 本身。

// 提取元组第一个元素类型
type First<T> = T extends [infer U, ...any[]] ? U : never;

type A = First<[number, string, boolean]>; // number

// 提取函数参数类型
type FirstArg<T> = T extends (arg: infer U, ...args: any[]) => any ? U : never;

type A = FirstArg<(x: number, y: string) => void>; // number

// 提取函数返回值类型
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

type A = ReturnType<() => boolean>; // boolean

// 提取构造函数实例类型
type InstanceType<T> = T extends new (...args: any[]) => infer R ? R : any;

class Foo {}
type A = InstanceType<typeof Foo>; // Foo

// 提取对象属性类型
type PropertyType<T> = T extends { prop: infer P } ? P : never;

type A = PropertyType<{ prop: number }>; // number
```

#### never 类型

在 TypeScript 中，never 表示“永远不会发生的类型”，即没有任何值能赋给它。

1. 不会返回的函数
   function throwError(): never {
   throw new Error('error');
   }
2. 一个函数里面无限循环 while(true){}

#### 存取器

```js
let passcode = "secret passcode";

class Employee {
private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }

}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
alert(employee.fullName);
}
```

注意：只带有 get 不带有 set 的存取器自动被推断为 readonly

#### 箭头函数的特点

1. 没有自己的 this
   箭头函数不会创建自己的 this，内部 this 继承自外层作用域（词法作用域）。
   适合用在回调、定时器等场景，避免 this 指向混乱。

2. 没有 arguments 对象
   箭头函数内部没有 arguments，需用 rest 参数 ...args 获取参数。

3. 不能作为构造函数
   不能用 new 调用箭头函数，否则会报错。

4. 没有 prototype 属性
   箭头函数没有 prototype，不能用作类或原型方法。

5. 不能使用 super 和 new.target
   箭头函数内部不能用 super 和 new.target。

#### new.target

new.target 是 ES6 引入的一个元属性，用于在构造函数或类的构造器内部，判断当前函数是否通过 new 关键字被调用，以及获取实际被 new 的构造函数。
new.target → 构造函数引用（不是实例）
常见用法：

```js
function Person() {
  if (!new.target) {
    throw new Error("必须使用 new 调用");
  }
}
new Person(); // 正常
Person(); // 报错
```

##### 什么是构造函数引用

```js
function Foo() {}
const ref = Foo; // 这里的 ref 就是构造函数引用
const obj = new Foo(); // obj 是实例对象

function Bar() {
  console.log(new.target === Bar); // true
}
new Bar(); // 构造函数引用就是 Bar 本身
```

##### 可以在构造函数或类里面用 new.target 实例化对象吗？不能

```js
function Bar() {
  const obj = new new.target(); // ❌ 这样会报错
}
```

#### uni-popup

弹框默认层级 z-index 是 99
（注：以下 A，B，C）均指 uni-popup

##### 情况一：

A，B 同级, 先打开 A 再打开 B，A 会把 B 盖住
弹出顺序：先弹 A → 再弹 B
展示顺序：A 盖住 B
即：微信渲染时，z-index 相同的元素，后渲染的会被前面渲染的覆盖（即后面的在下层）。在 Vue/uni-app 组件体系下，先渲染的 uni-popup（先插入 DOM），后渲染的在 DOM 结构上排在后面。

##### 情况二：

B 在 A 的 slot 里
弹出顺序：先弹 A → 再弹 B
展示顺序：B 盖住 A
会触发一个核心概念 **slot 区域的内容渲染优先级**

_slot 区域的内容渲染优先级_，指的是：
在 Vue 组件中，父组件的 slot（插槽）内渲染的内容，会在父组件的 DOM 结构中“占据”slot 位置，并且这些内容在 DOM 层级上属于父组件 slot 区域的子节点，这些内容在 DOM 结构上比父组件 slot 之外的内容“更靠上”，即使 z-index 相同，也会覆盖父组件 slot 区域同层的其他内容。

##### 情况三

A、C 同级，B 在 A 的 slot 里
弹出顺序：先弹 A → 再弹 C → 再弹 B
展示顺序：B 盖住 A 盖住 C

##### 情况四

A、C 同级，B 在 A 的 slot 里
弹出顺序：先弹 C → 再弹 A → 再弹 B
展示顺序：C 盖住 B 盖住 A

总结：层级相同时，如果 DOM 同级，那么，后渲染的会被前面渲染的覆盖，如果 DOM 不同级别，那么遵循**slot 区域的内容渲染优先级**
