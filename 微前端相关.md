### 微前端

微前端框架---qiankun（基于 single-spa，支持 Vue3，易用）

##### 文档：https://qiankun.umijs.org/zh/guide/getting-started

#### 如何引入微前端

##### 第一步：搭建一个主应用

1. 新建一个主应用（可用 Vue3、React、纯 HTML 均可，推荐用 Vue3 保持一致）。
2. 安装 qiankun：

```js
npm install qiankun
```

3. 在主应用中注册子应用：

```js
// main.ts
import { createApp } from "vue";
import App from "./App.vue";
import { registerMicroApps, start } from "qiankun";

createApp(App).mount("#app");

registerMicroApps([
  {
    name: "app1",
    entry: "//localhost:7101", // 子应用1的本地地址（如果同源）
    container: "#subapp-viewport",
    activeRule: "/app1",
  },
  {
    name: "app2",
    entry: "//localhost:7102", // 子应用2的本地地址（如果同源）
    container: "#subapp-viewport",
    activeRule: "/app2",
  },
]);

start();
```

4. 主应用页面预留子应用挂载点：

```js
<div id="subapp-viewport"></div>
```

5. 主应用的 route 文件还需要改造一下，详情见下方**二、主应用的路由配置**

##### 第二步：改造子应用的 maun.ts 动态渲染（即何时独立渲染、何时联合渲染）

1. 在每个子应用的 main.ts 里适配 qiankun：

```js
// main.ts
import { createApp } from "vue";
import App from "./App.vue";

let app = null;

function render(props = {}) {
  app = createApp(App);
  app.mount(props.container ? props.container.querySelector("#app") : "#app");
}

// 根据环境变量 决定是独立渲染还是动态渲染
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

// 挂载
export async function mount(props) {
  render(props);
}

// 卸载
export async function unmount() {
  app.unmount();
}
```

2. Vite 需加 base 配置，指定项目打包后所有静态资源（JS、CSS、图片等）的公共基础路径

##### 第三步：启动微前端项目

主应用、两个子应用分别启动（端口不能冲突）。
访问主应用，切换路由 /app1、/app2，即可看到两个子应用分别被加载。

### 常见问题

#### 样式隔离与数据隔离

##### 一、样式隔离

微前端场景下，主应用和各子应用的样式容易互相影响，常见的样式隔离方案有：

1. **Shadow DOM**

- 通过 Web Components 的 Shadow DOM 技术，将子应用包裹在 Shadow Root 内部，实现样式和 DOM 的天然隔离。
- 缺点：部分框架兼容性有限，第三方库支持不完善。

  **代码示例：**

假设你有一个子应用组件 `MyMicroApp`，可以用原生 Web Components 的方式包裹：

```js
// 主应用中
const container = document.getElementById("subapp-viewport");
const shadowRoot = container.attachShadow({ mode: "open" });
const app = document.createElement("div");
app.id = "micro-app-root";
shadowRoot.appendChild(app);
// 然后将子应用挂载到 #micro-app-root
```

// 子应用入口挂载时：

```js
// main.ts
import { createApp } from "vue";
import App from "./App.vue";

export function mount(props) {
  // props.container 是主应用传递的 shadowRoot
  createApp(App).mount(props.container.querySelector("#micro-app-root"));
}
```

这样，子应用的样式就被限制在 Shadow DOM 内部，不会影响主应用和其他子应用。

2. **CSS 前缀/命名空间**

- 通过构建工具（如 CSS Modules、Scoped CSS、BEM 命名规范等）为每个子应用样式加上独特前缀，避免样式冲突。

**介绍：**
CSS 前缀/命名空间是一种经典的样式隔离方案，通过人为地为每个子应用的样式类名、选择器等加上唯一标识，防止不同子应用之间的样式互相污染。

**常见方式：**

1. **CSS Modules**：
   - 通过 webpack、Vite 等工具链自动为每个组件生成唯一的类名（如 .App_button\_\_1a2b3），天然隔离。
   - 适用于 React、Vue 等现代前端框架。

```js
// 配置项说明：
// scopeBehaviour: 'local' 表示所有类名默认只在当前模块内生效（即样式隔离），可选 'global'（全局生效）。
// generateScopedName: '[name]__[local]___[hash:base64:5]' 控制生成的类名格式，
// 其中 [name] 是文件名，[local] 是原始类名，[hash:base64:5] 是5位哈希，保证唯一性和可读性。

/*
举个例子：
如果你在 CSS Modules 文件中写了 .page-cls，且 generateScopedName 配置为 '[name][local]_[hash:base64:5]'，假设你的样式文件名为 home.module.css，那么页面实际渲染出来的类名会变成：

home__page-cls___abcde

其中：

home 是文件名
page-cls 是你写的原始类名
abcde 是自动生成的 5 位哈希值（每次构建可能不同）
*/
export default {
  css: {
    modules: {
      scopeBehaviour: "local", // 默认为 local
      generateScopedName: "[name]__[local]___[hash:base64:5]",
    },
  },
};
```

2. **Scoped CSS（Vue 单文件组件）**：

   - 在 <style scoped> 下，Vue 会自动为当前组件样式加上 data-v-xxxx 属性选择器，保证只作用于本组件。

3. **BEM 命名规范**：

   - 通过 block\_\_element--modifier 结构人为区分不同模块，结合项目约定前缀（如 .app1-header、.app2-header）实现隔离。

4. **手动前缀**：
   - 在样式文件、类名、id 等统一加上子应用标识，如 .app1-btn、#app2-main。

**优点：**

- 简单易用，兼容性好。
- 不依赖浏览器新特性。

**缺点：**

- 需要团队规范和工具配合，手动前缀易出错。
- 不能彻底隔离全局样式（如 body、html 选择器）。

3. **CSS-in-JS**

- 使用 styled-components、emotion 等 CSS-in-JS 方案，样式作用域天然隔离。

4. **qiankun 的样式隔离机制**

- qiankun 默认提供两种样式隔离能力：
  - strictStyleIsolation: true 启用 Shadow DOM 隔离（前提是子应用根节点支持 attachShadow：**常见的 div、span、section、article、custom-element 等都支持 attachShadow，但像 body、html 这些标签不支持**）。
  - sandbox: { experimentalStyleIsolation: true } 启用样式选择器前缀隔离。
- 示例：
  ```js
  registerMicroApps(
    [
      {
        name: "app1",
        entry: "...",
        container: "#subapp-viewport",
        activeRule: "/app1",
        props: {},
        // ...
      },
    ],
    {
      sandbox: { strictStyleIsolation: true },
    }
  );
  ```

##### 二、数据隔离

数据隔离指主应用和各子应用之间的数据互不干扰，常见做法有：

1. **全局变量隔离（沙箱）**

**代码示例：**

// 主应用注册子应用时配置沙箱隔离：

```js
registerMicroApps(
  [
    {
      name: "app1",
      entry: "http://localhost:7101",
      container: "#subapp-viewport",
      activeRule: "/app1",
    },
  ],
  {
    sandbox: {
      // strict: true, // 开启严格沙箱（Proxy 沙箱，推荐生产环境）
      // loose: true, // 开启快照沙箱（兼容性更好，适合低版本浏览器）
    },
  }
);
```

// 子应用中的全局变量不会影响主应用：

```js
// 子应用代码
window.globalValue = "subapp";
console.log(window.globalValue); // 只在子应用沙箱内可见

// 主应用代码
console.log(window.globalValue); // undefined 或主应用自己的值
```

// 这样可以防止主/子应用互相污染 window 全局变量。

2. **props 通信**

**代码示例：**

// 主应用注册子应用时传递 props：

```js
registerMicroApps([
  {
    name: "app1",
    entry: "http://localhost:7101",
    container: "#subapp-viewport",
    activeRule: "/app1",
    props: {
      userInfo: { name: "张三", role: "admin" },
      onGlobalEvent: (msg) => console.log("主应用收到事件", msg),
    },
  },
]);
```

// 子应用 main.ts 获取 props：

```js
export async function mount(props) {
  console.log("子应用收到主应用传递的数据", props.userInfo);
  // 也可以调用 props.onGlobalEvent('hello from subapp')
}
```

// props 也可以在子应用组件内通过 inject/useProps 方式获取（视具体微前端框架而定）。

3. **自定义通信机制**

- 可以通过 EventBus、postMessage、全局状态管理（如 Redux、Vuex）等方式实现主子应用间通信，但需注意数据同步和隔离。

4. **localStorage/sessionStorage 隔离**

- 建议各应用使用不同的 key 前缀，避免本地存储冲突。

**总结：**

- 样式隔离推荐优先用 qiankun 的 strictStyleIsolation 或 experimentalStyleIsolation。
- 数据隔离依赖 qiankun 沙箱机制和 props 通信，复杂场景可自定义事件或全局状态管理。

#### 一、微前端的部署方式

不管那种方式，都推荐**正式环境子应用写完整的域名**

##### 两个子应用和主应用**部署在同一台服务器上**，只要端口或路径不冲突即可，主要有两种部署方式

1. 不同端口

```js
主应用：http://your-server:7000
子应用1：http://your-server:7101
子应用2：http://your-server:7102


registerMicroApps 里面的 entry 配置:
entry: "http://your-server:7101"
entry: "http://your-server:7102"
```

2. nginx 反向代理(-----推荐这种，同域不同路径”，方便 cookie、登录态共享和统一管理-----)

```js
// 简单的nginx配置
location /app1/ {
  proxy_pass http://localhost:7101/;
}

location /app2/ {
  proxy_pass http://localhost:7102/;
}


// registerMicroApps 里面的 entry 配置:
entry: "http://your-server/app1/"
entry: "http://your-server/app2/"
```

##### 两个子应用和主应用**部署在不同一台服务器上**

```js
// main.ts
// registerMicroApps里面的配置
registerMicroApps([
  {
    name: "app1",
    entry: "https://app1.example.com", // 子应用1的完整域名
    container: "#subapp-viewport",
    activeRule: "/app1",
  },
  {
    name: "app2",
    entry: "https://app2.example.com", // 子应用2的完整域名
    container: "#subapp-viewport",
    activeRule: "/app2",
  },
]);
```

#### 二、主应用的路由配置

##### 1. 原则：

- 主应用的路由只配置“子应用挂载点”，不配置子应用内部路由。
- 每个菜单项对应一个子应用的入口路由（如 /app1、/app2）。

##### 2. 例子：

```js
// router/index.ts
import { createRouter, createWebHistory } from "vue-router";

const routes = [
  {
    path: "/app1/:catchAll(.*)*", // 匹配所有 app1 下的路由
    component: () => import("@/views/SubAppContainer.vue"), // 子应用挂载容器
  },
  {
    path: "/app2/:catchAll(.*)*",
    component: () => import("@/views/SubAppContainer.vue"),
  },
  // 其它主应用自己的页面
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
```

##### 3. SubAppContainer.vue 文件里面一般会放 <div id="subapp-viewport"></div> 作为主应用的**挂载容器页面**，qiankun 会把子应用渲染到这个 div 里。注意:**不是引入子文件的 index.html**

#### 三、qiankun 的环境变量 window.`__POWERED_BY_QIANKUN__`

`__POWERED_BY_QIANKUN__`是 qiankun 框架在运行时自动挂载到 window 上的一个全局变量

- 当你的子应用被 qiankun 主应用加载时，qiankun 会自动在 window 上加上 window.`__POWERED_BY_QIANKUN__` = true。
- 当子应用独立运行时，这个变量不存在（undefined）。

##### 使用方法：

```js
if (!window.__POWERED_BY_QIANKUN__) {
  // 说明子应用此时在独立运行逻辑
}
```
